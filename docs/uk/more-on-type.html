<!DOCTYPE html><html lang="uk"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Більше про типи · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## Type Argument!"/><meta name="docsearch:language" content="uk"/><meta property="og:title" content="Більше про типи · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/index.html"/><meta property="og:description" content="## Type Argument!"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><link rel="stylesheet" href="/css/main.css"/></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/uk"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/uk/quickstart-javascript" target="_self">Документація</a></li><li class=""><a href="/uk/try" target="_self">Спробуйте</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/uk/community" target="_self">Спільнота</a></li><li class=""><a href="/blog" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg"/>Українська</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/more-on-type">日本語</a></li><li><a href="/docs/en/more-on-type">English</a></li><li><a href="/docs/de/more-on-type">Deutsch</a></li><li><a href="/docs/es-ES/more-on-type">Español</a></li><li><a href="/docs/fr/more-on-type">Français</a></li><li><a href="/docs/ko/more-on-type">한국어</a></li><li><a href="/docs/pt-BR/more-on-type">Português (Brasil)</a></li><li><a href="/docs/ru/more-on-type">Русский</a></li><li><a href="/docs/zh-CN/more-on-type">中文</a></li><li><a href="/docs/zh-TW/more-on-type">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Допоможіть перекласти</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Основи мови</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Введення</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/what-and-why">Що і чому</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Налаштування текстових редакторів</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/editor-plugins">Плагіни для редакторів</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/extra-goodies">Додаткові приколи</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Основи мови</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/overview">Огляд</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/let-binding">Let Binding</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/type">Тип!</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/string-and-char">Рядок та символ</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/boolean">Логічний тип</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/integer-and-float">Цілі числа та числа з плаваючою точкою</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/tuple">Кортеж</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/record">Запис</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/variant">Варіант!</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/list-and-array">Список і масив</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/function">Функція</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/if-else">If-Else</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/uk/more-on-type">Більше про типи</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/destructuring">Розбиття</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/pattern-matching">Зіставлення з шаблоном!</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/mutation">Мутація</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/imperative-loops">Імперативні цикли</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/external">Зовнішній</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/exception">Виключення</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/object">Об&#x27;єкт</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/module">Модуль</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/promise">Обіцянка</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/quickstart-javascript">Швидкий старт</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/interop">Взаємодія</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/syntax-cheatsheet">Синтаксис Шпаргалка</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/libraries">Бібліотеки</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/converting-from-js">Перехід з JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/quickstart-ocaml">Швидкий старт</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/convert-from-ocaml">Перехід з OCaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Додатково</h3><ul><li class="navListItem"><a class="navItem" href="/docs/uk/faq">Найбільш поширенні питання</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/comparison-to-ocaml">Порівняння до OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/newcomer-examples">Приклади для новачків</a></li><li class="navListItem"><a class="navItem" href="/docs/uk/project-structure">Структура проекту</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/uk" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Більше про типи</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="type-argument"></a><a href="#type-argument" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Type Argument!</h2>
<p>Types can accept parameters, akin to generics in other languages. It's as if a type is a function that takes in arguments and returns a new type! The parameters <strong>need</strong> to start with <code>'</code>.</p>
<p>The use-case of a parameterized type is to kill duplications. Before:</p>
<pre><code class="hljs css languages- reason">/* this <span class="hljs-keyword">is</span> a <span class="hljs-keyword">tuple</span> <span class="hljs-keyword">of</span> <span class="hljs-number">3</span> items, explained next */
<span class="hljs-keyword">type</span> intCoordinates = (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>);
<span class="hljs-keyword">type</span> floatCoordinates = (<span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>, <span class="hljs-built_in">float</span>);

<span class="hljs-keyword">let</span> buddy: intCoordinates = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);
</code></pre>
<p>After:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">type</span> coordinates(<span class="hljs-symbol">'a</span>) = (<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'a</span>);

/* apply the coordinates <span class="hljs-string">"type function"</span> <span class="hljs-keyword">and</span> return the <span class="hljs-keyword">type</span> (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>) */
<span class="hljs-keyword">type</span> intCoordinatesAlias = coordinates(<span class="hljs-built_in">int</span>);

<span class="hljs-keyword">let</span> buddy: intCoordinatesAlias = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);

/* <span class="hljs-keyword">or</span>, more commonly, write it inline */
<span class="hljs-keyword">let</span> buddy: coordinates(<span class="hljs-built_in">float</span>) = (<span class="hljs-number">10.5</span>, <span class="hljs-number">20.5</span>, <span class="hljs-number">20.5</span>);
</code></pre>
<p>In practice, types are inferred for you. So the more concise version of the above example would be nothing but:</p>
<pre><code class="hljs css languages- reason">let buddy = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);
</code></pre>
<p>The type system infers that it's a <code>(int, int, int)</code>. Nothing else needed to be written down.</p>
<p>Type arguments appear everywhere.</p>
<pre><code class="hljs css languages- reason">/* inferred <span class="hljs-keyword">as</span> `<span class="hljs-built_in">list</span>(<span class="hljs-built_in">string</span>)` */
<span class="hljs-keyword">let</span> greetings = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>];
</code></pre>
<p>If types didn't accept parameters (ie, if we didn't have &quot;type functions&quot;), the standard library would need to define the types <code>listOfString</code>, <code>listOfInt</code>, <code>listOfTuplesOfInt</code>, etc.</p>
<p>Types can receive more arguments, and be composable.</p>
<pre><code class="hljs css languages- reason"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">result</span></span>(<span class="hljs-symbol">'a</span>, <span class="hljs-symbol">'b</span>) =
  | <span class="hljs-literal">Ok</span>(<span class="hljs-symbol">'a</span>)
  | Error(<span class="hljs-symbol">'b</span>);

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">myPayload</span></span> = {data: string};

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">myPayloadResults</span></span>(<span class="hljs-symbol">'errorType</span>) = list(result(myPayload, <span class="hljs-symbol">'errorType</span>));

<span class="hljs-keyword">let</span> payloadResults: myPayloadResults(string) = [
  <span class="hljs-literal">Ok</span>({data: <span class="hljs-string">"hi"</span>}),
  <span class="hljs-literal">Ok</span>({data: <span class="hljs-string">"bye"</span>}),
  Error(<span class="hljs-string">"Something wrong happened!"</span>)
];
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="mutually-recursive-types"></a><a href="#mutually-recursive-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutually Recursive Types</h2>
<p>Just like functions, types can be mutually recursive through <code>and</code>:</p>
<pre><code class="hljs css languages- reason"><span class="hljs-keyword">type</span> <span class="hljs-type">student </span>= {taughtBy: teacher}
<span class="hljs-keyword">and</span> teacher = {students: list(student)};
</code></pre>
<p><strong>Note</strong> that there's no semicolon ending the first line and no <code>type</code> on the second line.</p>
<h2><a class="anchor" aria-hidden="true" id="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h2>
<p>A type system allowing type argument is basically allowing type-level functions. <code>list(int)</code> is really the <code>list</code> type function taking in the <code>int</code> type, and returning the final, concrete type you'd use in some places. You might have noticed that in other languages, this is more or less called &quot;generics&quot;. For example, <code>ArrayList&lt;Integer&gt;</code> in Java.</p>
<p><a href="https://en.wikipedia.org/wiki/Rule_of_least_power">The principle of least power</a> applies when you're trying to &quot;Get Things Done&quot;. If the problem domain allows, definitely pick the least abstract (aka, the most concrete) solution available, so that the solution is reached faster and has fewer unstable indirections you'd have to traverse. For example, prefer types over free-form data, prefer data-driven configuration over turing-complete function calls, prefer function calls over macros, prefer macros over project forks, etc. When you constrain your domain and power, things become easier to analyze. That is, <em>if</em> the domain is constrained enough to allow it.</p>
<p>When a type system is an all-encompassing aspect of your program, we need to make sure we leave enough power in order not to overly constrain your expressiveness; without &quot;type functions&quot;, you'd end up with quite a bit of boilerplate, e.g. hard-coded <code>listOfInt</code>, <code>listOfString</code>, <code>listOfArrayOfFloat</code>, their respective helper functions, etc. However, please also make sure you don't overly abuse the power given to you through a rather powerful type system. Sometimes, it's fine to write a <em>little</em> bit of boilerplate to reduce the need for otherwise extra powerful types. If anything, tasteful tradeoffs might show your pragmatism and judgement more than fancy types!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/uk/if-else">← If-Else</a><a class="docs-next button" href="/docs/uk/destructuring">Розбиття →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#type-argument">Type Argument!</a></li><li><a href="#mutually-recursive-types">Mutually Recursive Types</a></li><li><a href="#design-decisions">Design Decisions</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script><script src="/js/pjax-api.min.js"></script><script>window.foo = new Pjax({
          areas: [
            // try to use the first query.
            '.mainContainer, .docsNavContainer .toc .navWrapper, .onPageNav',
            // fallback
            'body'
          ],
          link: '.docsNavContainer:not(.docsSliderActive) a',
          update: {
            script: false,
          }
        });
        var languagesMenuItemCopy = document.getElementById("languages-menu");
        languagesMenuItemCopy.addEventListener("click", function(e){
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation();
        });</script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:uk"]}
              });
            </script></body></html>