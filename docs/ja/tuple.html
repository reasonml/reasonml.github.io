<!DOCTYPE html><html lang="ja"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>タプル · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Tuples are like JavaScript arrays:"/><meta name="docsearch:language" content="ja"/><meta property="og:title" content="タプル · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="Tuples are like JavaScript arrays:"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ja"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ja/what-and-why" target="_self">ドキュメント</a></li><li class=""><a href="/ja/try" target="_self">試してみる</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/ja/community" target="_self">コミュニティ</a></li><li class=""><a href="/blog/" target="_self">ブログ</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>日本語</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/en/tuple">English</a></li><li><a href="/docs/de/tuple">Deutsch</a></li><li><a href="/docs/es-ES/tuple">Español</a></li><li><a href="/docs/fr/tuple">Français</a></li><li><a href="/docs/ko/tuple">한국어</a></li><li><a href="/docs/pt-BR/tuple">Português (Brasil)</a></li><li><a href="/docs/ru/tuple">Русский</a></li><li><a href="/docs/uk/tuple">Українська</a></li><li><a href="/docs/zh-CN/tuple">中文</a></li><li><a href="/docs/zh-TW/tuple">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">翻訳を助ける</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>言語の基本</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">はじめに</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/what-and-why">What &amp; Why</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">セットアップ</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/installation">インストール</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/editor-plugins">エディタのプラグイン</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/extra-goodies">Extra Goodies</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">言語の基本</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/overview">概要</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/let-binding">Let バインディング</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/type">型！</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/string-and-char">String &amp; Character</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/regular-expression">Regular Expression</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/boolean">Boolean</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/integer-and-float">Integer &amp; Float</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ja/tuple">タプル</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/record">Record</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/null-undefined-option">NullとUndefinedとOption</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/list-and-array">リストと配列</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/function">Function</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/more-on-type">More on Type</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/destructuring">構造化代入</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/pattern-matching">パターンマッチング！</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/mutation">Mutation</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/imperative-loops">命令的なループ</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/exception">例外</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/object">Object</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/module">モジュール</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/promise">Promise</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/interop">Interop</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/syntax-cheatsheet">Syntax Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/libraries">ライブラリ</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/converting-from-js">JS からの変換</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Native</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/native">Native</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/quickstart-ocaml">Native Quickstart</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ja/faq">よくある質問</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/newcomer-examples">Newcomer Examples</a></li><li class="navListItem"><a class="navItem" href="/docs/ja/project-structure">プロジェクトの構成</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/ja" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">タプル</h1></header><article><div><span><p>Tuples are like JavaScript arrays:</p>
<ul>
<li>ordered collection of items</li>
<li><strong>compile to JavaScript arrays</strong></li>
</ul>
<p>But on the Reason side, they're also different than JS arrays. They're:</p>
<ul>
<li>immutable</li>
<li>fix-sized at creation time</li>
<li>heterogeneous (can contain different types of values)</li>
</ul>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-343-tab-344" class="nav-link active" data-group="group_343" data-tab="tab-group-343-content-344">Reason</div><div id="tab-group-343-tab-345" class="nav-link" data-group="group_343" data-tab="tab-group-343-content-345">Output</div></div><div class="tab-content"><div id="tab-group-343-content-344" class="tab-pane active" data-group="group_343" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> ageAndName = (<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>);<br /><span class="hljs-keyword">let</span> my3dCoordinates = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /></code></pre>
</span></div></div><div id="tab-group-343-content-345" class="tab-pane" data-group="group_343" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> ageAndName = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>];<br /><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /></code></pre>
</span></div></div></div></div>
<p>Because tuples turn into JavaScript arrays, when you receive an existing JS array from the JS side of your codebase, you can also model it as a tuple on the Reason side, providing that said array have the characterics above (fixed-sized, potentially heterogenous, etc.).</p>
<p>Like most of Reason, you don't have to write down the tuple's type signature. If you want to, here's the syntax:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-346-tab-347" class="nav-link active" data-group="group_346" data-tab="tab-group-346-content-347">Reason</div><div id="tab-group-346-tab-348" class="nav-link" data-group="group_346" data-tab="tab-group-346-content-348">Output</div></div><div class="tab-content"><div id="tab-group-346-content-347" class="tab-pane active" data-group="group_346" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> ageAndName: (int, string) = (<span class="hljs-number">24</span>, <span class="hljs-string">"Lil' Reason"</span>);<br /><br /><span class="hljs-keyword">type</span> coord3d = (float, float, float); <span class="hljs-comment">/* a type alias for a tuple */</span><br /><span class="hljs-keyword">let</span> my3dCoordinates: coord3d = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /></code></pre>
</span></div></div><div id="tab-group-346-content-348" class="tab-pane" data-group="group_346" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> ageAndName = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">16</span>, <span class="hljs-string">"Lil' Reason"</span>];<br /><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /></code></pre>
</span></div></div></div></div>
<p><strong>Note</strong>: there's no tuple of size 1. You'd just use the value itself.</p>
<h2><a class="anchor" aria-hidden="true" id="使い方"></a><a href="#使い方" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使い方</h2>
<p>Unlike Reason and JS Arrays, you don't access a tuple through the indexing operator, e.g. <code>myTuple[0]</code>. Generally, you'd access the items through destructuring (described later in the sidebar):</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-349-tab-350" class="nav-link active" data-group="group_349" data-tab="tab-group-349-content-350">Reason</div><div id="tab-group-349-tab-351" class="nav-link" data-group="group_349" data-tab="tab-group-349-content-351">Output</div></div><div class="tab-content"><div id="tab-group-349-content-350" class="tab-pane active" data-group="group_349" tabindex="-1"><div><span><pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> my3dCoordinates = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>);<br /><span class="hljs-keyword">let</span> (_, y, _) = my3dCoordinates; <span class="hljs-comment">/* now you've retrieved y */</span><br /></code></pre>
</span></div></div><div id="tab-group-349-content-351" class="tab-pane" data-group="group_349" tabindex="-1"><div><span><pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> my3dCoordinates = <span class="hljs-comment">/* tuple */</span>[<span class="hljs-number">20.0</span>, <span class="hljs-number">30.5</span>, <span class="hljs-number">100.0</span>];<br /><span class="hljs-keyword">var</span> y = <span class="hljs-number">30.5</span>;<br /></code></pre>
</span></div></div></div></div>
<p>The <code>_</code> means you're ignoring those other members of the tuple.</p>
<p>This is slightly inconvenient if you constantly access a tuple's nth item (which should be rare). You can write your own helper function for accessing the nth item of a tuple in that case.</p>
<p>Tuples aren't meant to be updated mutatively; you'd instead pull out the old one's relevant values and stuff them into a new tuple.</p>
<h2><a class="anchor" aria-hidden="true" id="ヒントとコツ"></a><a href="#ヒントとコツ" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ヒントとコツ</h2>
<p>You'd use tuples in handy situations that pass around multiple values without too much ceremony. For example, to return many values:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> getCenterCoordinates = () =&gt; {
  <span class="hljs-keyword">let</span> x = doSomeOperationsHere();
  <span class="hljs-keyword">let</span> y = doSomeMoreOperationsHere();
  (x, y)
};
</code></pre>
<p>Or to &quot;pattern-match&quot; (covered later) on the conjunction of possibilities:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">switch</span> (isWindowOpen, isDoorOpen) { <span class="hljs-comment">/* this is a 2-tuple */</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>) =&gt; <span class="hljs-operator">...</span>
| (<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>) =&gt; <span class="hljs-operator">...</span>
}
</code></pre>
<p>Try to keep the usage of tuple <strong>local</strong>. For data structures that are long-living and passed around often, prefer a <strong>record</strong>, which has named fields.</p>
<p>A tuple type might also be called a &quot;product type&quot;, and <code>(string, int)</code> is written as <code>string * int</code> in some places. The idea is that a tuple is really a &quot;cartesian product&quot;; imagine a 2D grid, with <code>string</code> on the x axis and <code>int</code> on the y axis!</p>
<p>The combination of tuple + <code>switch</code> is very powerful and concise, and <strong>wipes out an entire category of bugs</strong>. Together, they cleanly list out all the possible combinations of values. A tuple of type <code>(bool, bool)</code> indeed has <code>2 * 2 = 4</code> possibilities, and the type system asks you to cover all 4. This lends itself well to code refactors; instead of informally adding a few if-else on arbitrary values here and there, you can directly pinpoint the exact <code>switch</code> branch you need to alter, no more and no less.</p>
<h2><a class="anchor" aria-hidden="true" id="設計方針"></a><a href="#設計方針" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>設計方針</h2>
<p>The existence of tuples might seem odd for those coming from untyped languages. &quot;Why not just use an array?&quot;</p>
<p>A type system isn't all-powerful, nor should it be; some tasteful trade-offs need to be applied in order to keep the language simple, performant (both compilation and running speed) and easy to understand. Reason lists, for example, are more flexible in size; they can be concatenated, appended, sliced, etc. In return, they need to be homogenous (can only contain a single type of value per list), and random index access on them might not always be valid*. Tuple, on the other hand, through its constraint on size, is faster, gives the type system the leeway to exhaustively track all its items' types, and guarantees safe access. In general, you'll notice a few prominent, tasteful tradeoffs in a type system: record fields are fixed but can be heterogenous, while a map's fields are flexible but homogenous, etc.</p>
<p>A Reason tuple is typed &quot;structurally&quot;. This means that even if you don't annotate your data with an explicit type, the compiler can still deduce it by looking at its content, its usage, etc. As long as the declarations and the usages' inferred shapes match up, you're all good!</p>
<p>* It's not that the Reason type system cannot accept heterogenous, dynamically-sized lists; it actually can in some circumstances, but making such feature the default increases both the first-time learning overhead and the understandability of code. Just because the types can accomplish it doesn't mean it's always a good idea to let some pieces of code grow unboundedly complex!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ja/integer-and-float"><span class="arrow-prev">← </span><span>Integer &amp; Float</span></a><a class="docs-next button" href="/docs/ja/record"><span>Record</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#使い方">使い方</a></li><li><a href="#ヒントとコツ">ヒントとコツ</a></li><li><a href="#設計方針">設計方針</a></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ja"]}
              });
            </script></body></html>