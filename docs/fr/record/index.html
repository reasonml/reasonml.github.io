<!DOCTYPE html><html lang="fr"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Records · Reason</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="*Quick overview: [Records](/docs/fr/overview#records)*"/><meta name="docsearch:language" content="fr"/><meta property="og:title" content="Records · Reason"/><meta property="og:type" content="website"/><meta property="og:url" content="https://reasonml.github.io/"/><meta property="og:description" content="*Quick overview: [Records](/docs/fr/overview#records)*"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/icon_50.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://reasonml.github.io/blog/atom.xml" title="Reason Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://reasonml.github.io/blog/feed.xml" title="Reason Blog RSS Feed"/><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/fr"><img class="logo" src="/img/dummy.svg" alt="Reason"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/fr/what-and-why" target="_self">Documentation</a></li><li class=""><a href="/fr/try" target="_self">Essayer</a></li><li class=""><a href="/api/index" target="_self">API</a></li><li class=""><a href="/docs/fr/community" target="_self">Communauté</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Français</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/record">日本語</a></li><li><a href="/docs/en/record">English</a></li><li><a href="/docs/de/record">Deutsch</a></li><li><a href="/docs/es-ES/record">Español</a></li><li><a href="/docs/ko/record">한국어</a></li><li><a href="/docs/pt-BR/record">Português (Brasil)</a></li><li><a href="/docs/ru/record">Русский</a></li><li><a href="/docs/uk/record">Українська</a></li><li><a href="/docs/zh-CN/record">中文</a></li><li><a href="/docs/zh-TW/record">繁體中文</a></li><li><a href="https://crowdin.com/project/reason" target="_blank" rel="noreferrer noopener">Aider à la traduction</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/reason" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Principes de base du langage</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/what-and-why">Quoi &amp; Pourquoi</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Installation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/installation">Installation</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/editor-plugins">Plugins éditeurs</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/extra-goodies">Goodies supplémentaires</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Principes de base du langage</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/overview">Aperçu</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/let-binding">Let Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/primitives">Primitives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/type">Type !</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/basic-structures">Basic Structures</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/fr/record">Records</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/variant">Variant!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/null-undefined-option">Null, Undefined &amp; Option</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/function">Fonction</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/recursion">Recursion</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/if-else">If-Else</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/more-on-type">Plus sur les types</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/destructuring">Destructuring</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pattern-matching">Pattern Matching!</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/mutable-bindings">Mutable Bindings</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/imperative-loops">Boucles impératives</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/module">Module</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/jsx">JSX</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/external">External</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/exception">Exception</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/object">Objet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">JavaScript</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/interop">Interopérabilité</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/syntax-cheatsheet">Cheatsheet de la syntaxe</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/pipe-first">Pipe First</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/promise">Promesse</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/libraries">Bibliothèques</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/converting-from-js">Convertir depuis JavaScript</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Natif</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/native">Natif</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/quickstart-ocaml">Démarrage rapide en natif</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/fr/faq">Foire aux Questions</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/newcomer-examples">Exemple pour Débutants</a></li><li class="navListItem"><a class="navItem" href="/docs/fr/project-structure">Structure de projet</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/reason/fr" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Records</h1></header><article><div><span><p><em>Quick overview: <a href="/docs/fr/overview#records">Records</a></em></p>
<p>Records are structures used for storing data in named fields. They are similar to objects or structs in other languages. Records are very performant and can be used in hot code paths.</p>
<p><em>Note: Record types are <a href="https://en.wikipedia.org/wiki/Nominal_type_system">nominal</a>. This has some important consequences that we will explore <a href="#nominal-typing">later on</a>.</em></p>
<h2><a class="anchor" aria-hidden="true" id="defining-a-record"></a><a href="#defining-a-record" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining a Record</h2>
<p>In order to use a record, you must first declare a type for it:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
  age: int,
};
</code></pre>
<p>From this point on the <code>person</code> record can be created and the correct type will be inferred. It does not have to be annotated:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="accessing-fields"></a><a href="#accessing-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessing Fields</h2>
<p>Access fields on a record by using a <code>.</code> followed by the field name:</p>
<pre><code class="hljs css language-reason">print_endline(<span class="hljs-string">"Hello "</span> <span class="hljs-operator">++</span> alice.name);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="updating-records-spreading"></a><a href="#updating-records-spreading" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Updating Records &amp; Spreading</h2>
<p>Record fields are <strong>immutable</strong> by default and cannot be changed. To &quot;update&quot; a record, you will typically start with some existing record and use the spread syntax to update the desired set of fields:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="mutable-records"></a><a href="#mutable-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable Records</h2>
<p>Records do support mutable fields, and this is how <a href="/docs/fr/overview#refs">Mutable Bindings</a> are implemented:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> mutablePerson = {
  name: string,
  <span class="hljs-keyword">mutable</span> age: int,
};

<span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  person.age = person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="nominal-typing"></a><a href="#nominal-typing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nominal Typing</h2>
<p>Records use nominal typing, which means that only records that have exactly the same type are compatible with each other. Two different record types with the exact same fields cannot be used in place of one another.</p>
<p>This comes up most often when trying to spread one record that has a subset of fields into another record:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> baby = {
  name: string,
  age: int,
};

<span class="hljs-keyword">type</span> adult = {
  name: string,
  age: int,
  job: string,
};

<span class="hljs-keyword">let</span> hire = (baby: baby, job): adult =&gt; {
  <span class="hljs-comment">/* Error: Unexpected type */</span>
  {<span class="hljs-operator">...</span>baby, job: job};
};
</code></pre>
<p>Instead, the conversion has to be done manually and cover all fields:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> hire = (baby: baby, job): adult =&gt; {
  {
    name: baby.name,
    age: baby.age,
    job: job,
  };
};
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tips"></a><a href="#tips" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips</h2>
<h3><a class="anchor" aria-hidden="true" id="shorthand-notation"></a><a href="#shorthand-notation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Shorthand Notation</h3>
<p>Fields of records are often constructed using bindings with the exact same name. A shorthand notation can be used:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> name = <span class="hljs-string">"Alice"</span>;
<span class="hljs-keyword">let</span> age = <span class="hljs-number">42</span>;

<span class="hljs-comment">/* With shorthand */</span>
<span class="hljs-keyword">let</span> alice = {name, age};

<span class="hljs-comment">/* Without shorthand */</span>
<span class="hljs-keyword">let</span> alice = {name: name, age: age};
</code></pre>
<p><em>Warning: There is a &quot;gotcha&quot; when working with only one field, see <a href="#single-field-records">Single Field Records</a> below.</em></p>
<h3><a class="anchor" aria-hidden="true" id="providing-all-fields"></a><a href="#providing-all-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Providing All Fields</h3>
<p>When working with large records it can be annoying to provide all fields when there are sensible defaults. Two ways to work around this are by using a default record everywhere:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> defaultPerson = {
  name: <span class="hljs-string">"Unknown"</span>,
  age: <span class="hljs-number">0</span>,
};

<span class="hljs-keyword">let</span> alice = {
  <span class="hljs-operator">...</span>defaultPerson,
  name: <span class="hljs-string">"Alice"</span>,
};
</code></pre>
<p>Or by creating a builder function:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> makePerson = (
  ~name=<span class="hljs-string">"Unknown"</span>,
  ~age=<span class="hljs-number">0</span>,
  (),
) =&gt; {
  {name, age};
};

<span class="hljs-comment">/* The final unit is important. It lets the compiler know you're "done". */</span>
<span class="hljs-keyword">let</span> alice = makePerson(~name=<span class="hljs-string">"Alice"</span>, ());
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="troubleshooting"></a><a href="#troubleshooting" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Troubleshooting</h2>
<h3><a class="anchor" aria-hidden="true" id="add-an-explicit-annotation"></a><a href="#add-an-explicit-annotation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Add an Explicit Annotation</h3>
<p>There are quite a few different issues that can come up when using records and it can feel like you are fighting the type system. A general approach to figuring out what the type system wants you to do is to add explicit annotations and see if that fixes, moves, or changes the error.</p>
<p>This approach can be used to fix or diagnose all of the following issues.</p>
<h3><a class="anchor" aria-hidden="true" id="unbound-record-field"></a><a href="#unbound-record-field" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unbound Record Field</h3>
<p>The record type must be in scope to build records of that type; otherwise, there will be an &quot;Unbound Record Field&quot; error.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Person</span> = {
  <span class="hljs-keyword">type</span> t = {
    name: string,
    age: int,
  };
};

<span class="hljs-keyword">let</span> alice = {
  <span class="hljs-comment">/* Error: Unbound record field */</span>
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>Fix this by adding an explicit type:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice: <span class="hljs-module-identifier">Person</span>.t = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>Or by opening the module:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">open</span> <span class="hljs-module-identifier">Person</span>;

<span class="hljs-keyword">let</span> alice = {
  name: <span class="hljs-string">"Alice"</span>,
  age: <span class="hljs-number">42</span>,
};
</code></pre>
<p>There is also an odd syntax that you might come across when working with records with the type out of scope. Fields can be referenced by <code>Module.field</code> instead of just <code>.field</code>. This is discouraged in favor of the prior approaches, but is something to be aware of:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> alice = {
  <span class="hljs-module-identifier">Person</span>.name: <span class="hljs-string">"Alice"</span>,
  <span class="hljs-module-identifier">Person</span>.age: <span class="hljs-number">42</span>,
};

<span class="hljs-keyword">let</span> getName = (person) =&gt; {
  person.<span class="hljs-module-identifier">Person</span>.name;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="disambiguating-record-types"></a><a href="#disambiguating-record-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Disambiguating Record Types</h3>
<p>If records have any field names in common the type system can get confused. The type inference will pick one of the types that matches the first field it sees and use that as the type, even if later fields are incompatible.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  age: int,
  name: string,
};

<span class="hljs-keyword">type</span> wine = {
  age: int,
  kind: string,
};

<span class="hljs-keyword">let</span> happyBirthday = person =&gt; {
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  <span class="hljs-comment">/* Error: The field name does not belong to type wine */</span>
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  next;
};
</code></pre>
<p>Fix this by adding an explicit type:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person: person) =&gt; {
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  next;
};
</code></pre>
<p>Or, a less reliable fix is to reorder the usage of fields so an unambiguous field is seen first:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> happyBirthday = (person) =&gt; {
  print_endline(<span class="hljs-string">"Happy Birthday "</span> <span class="hljs-operator">++</span> person.name);
  <span class="hljs-keyword">let</span> next = {<span class="hljs-operator">...</span>person, age: person.age <span class="hljs-operator">+</span> <span class="hljs-number">1</span>};
  next;
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="single-field-records"></a><a href="#single-field-records" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Single Field Records</h3>
<p>There is an uncommon edge-case when using <a href="#shorthand-notation">Shorthand Notation</a> with records containing only one field. In the following example, taking into account shorthand notation, try to determine:</p>
<ul>
<li>Does the function return a person with the name field set as name?</li>
<li>Does the function return the name argument?</li>
</ul>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  name: string,
};

<span class="hljs-keyword">let</span> fn = (name) =&gt; {
  name
};
</code></pre>
<p>If single-field records are allowed to use shorthand notation this is ambiguous. That is not okay in a language! To avoid this ambiguity single-field records always have to have both field and value written:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> fnName = (name): string =&gt; {
  name
};

<span class="hljs-keyword">let</span> fnPerson = (name): person =&gt; {
  name: name
};
</code></pre>
<p>This is an uncommon case because single-field records are uncommon. Typically instead of having a record type you would use the type of the single field directly (a notable exception is the <a href="/docs/fr/overview#refs"><code>ref</code> record type</a>).</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/fr/basic-structures"><span class="arrow-prev">← </span><span>Basic Structures</span></a><a class="docs-next button" href="/docs/fr/variant"><span>Variant!</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#defining-a-record">Defining a Record</a></li><li><a href="#accessing-fields">Accessing Fields</a></li><li><a href="#updating-records-amp-spreading">Updating Records &amp; Spreading</a></li><li><a href="#mutable-records">Mutable Records</a></li><li><a href="#nominal-typing">Nominal Typing</a></li><li><a href="#tips">Tips</a><ul class="toc-headings"><li><a href="#shorthand-notation">Shorthand Notation</a></li><li><a href="#providing-all-fields">Providing All Fields</a></li></ul></li><li><a href="#troubleshooting">Troubleshooting</a><ul class="toc-headings"><li><a href="#add-an-explicit-annotation">Add an Explicit Annotation</a></li><li><a href="#unbound-record-field">Unbound Record Field</a></li><li><a href="#disambiguating-record-types">Disambiguating Record Types</a></li><li><a href="#single-field-records">Single Field Records</a></li></ul></li></ul></nav></div><span><script src="/js/redirectBlog.js"></script></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '966d1e412f67114a07dc0afe44b19b53',
                indexName: 'reason',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:fr"]}
              });
            </script></body></html>