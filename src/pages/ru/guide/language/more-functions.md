---
title: Подробнее про функции
order: 6
---

#### Рекурсивные функции

По умолчанию значения не могут видеть имена переменных к которым они присвоены.
Можно обойти это ограничение используя ключевое слово `rec` внутри `let`.
Это позволяет функциям видеть самих себя, что дает нам возможность рекурсии.


```reason
let rec neverTerminate = fun () => neverTerminate ();
```

#### Взаимно рекурсивные функции

Взаимно рекурсивные функции объявляются как рекурсивная функция, но между
ними используется ключевое слово `and`:

```reason
let rec callSecond = fun () => callFirst ()
and callFirst = fun () => callSecond ();
```

**Заметте**, что точка с запятой только на второй строке.

#### Каррирование

Функции в Reason могут быть **частично (partially)** вызваны:

```reason
let add = fun x y => x + y;
let addFive = add 5;
let eleven = addFive 6;
let twelve = addFive 7;
```

Описанная выше функция `add` на самом деле просто сахар для:

```reason
let add = fun x => fun y => x + y;
```

OCaml оптимизирует это, чтобы избежать лишнего выделения памяти для функции когда это
возможно. Таким образом мы имеем:

- Удобный синтаксис
- Каррирование бесплатно (на самом деле каждая функция принимает только один аргумент)
- Нет оверхеда по производительности
