---
title: Модули
order: 12
---

### Базовая информация

**Модули похожи на минифайлы**! Они могут содержать определения типов, `let`
привязки, вложенные модули, и так далее.

#### Создание

Для создания модуля используется ключевое слово `module`. Имя модуля должно
начинаться **заглавной буквы**. Все что вы можете положить в `.re` файл, вы
также можете положит внутрь блока `{}` модуля.

```reason
module School = {
  type profession = Teacher | Director;

  let person1 = Teacher;
  let getProfession person =>
    switch person {
    | Teacher => "A teacher"
    | Director => "A director"
    };
};
```

Содержимое модуля (в том числе и типы!) доступно при помощи `.`. То есть модуль
можно использовать как пространство имен.

```reason
let anotherPerson: School.profession = School.Teacher;
print_endline (School.getProfession anotherPerson); /* "A teacher" */
```

Можно создавать вложенные модули:

```reason
module MyModule = {
  module NestedModule = {
     let message = "hello";
  };
};

let message = MyModule.NestedModule.message;
```

#### Открытие (`open`) модуля

Постоянно использовать имя модуля, чтобы ссылаться на его содержимое может быть
неудобно. Мы можем открыть модуль, и ссылаться на содержимое напрямую. Есть
два способа это сделать:

Локальное открытие.

```reason
let message =
  School.(
    switch person1 {
    | Teacher => "Hello teacher!"
    | Director => "Hello director!"
    }
  );
```

Глобальное открытие. **Старайтесь не использовать этот способ**:

```reason
open School;
let anotherPerson: profession = Teacher;
printProfession anotherPerson;
```

#### Расширение модулей

Использование `include` копирует содержимое модуля в другой модуль. Это часто играет
роль наследования или миксинов.

```reason
module BaseComponent = {
  let defaultGreeting = "Hello";
  let getAudience ::excited => excited ? "world!" : "world";
};

module ActualComponent = {
  /* Контент копируется */
  include BaseComponent;
  /* Переопределяет BaseComponent.defaultGreeting */
  let defaultGreeting = "Hey";
  let render () => defaultGreeting ^ " " ^ getAudience excited::true;
};
```

**Важно:**: `include` и `open` совершенно различны! Первый полностью копирует
содержимое модуля. Последний позволяет просто ссылаться на элементы (значения,
типы, конструкторы, и так далее) без указания имени модуля (например `foo` вместо
`MyModule.foo`)

#### Каждый `.re` файл является модулем

В OCaml/Reason файл является модулем. Это открывает интересные возможность, для
которых в других языках требуется генерация кода. Например, файл `react.re` —
это модуль `React`, который можно использовать в других файлах.

```reason
/* fileA.re. Компилируется как FileA */
let a = 1;
let b = 2;

/* fileB.re */
/* Отображает имплементацию fileA в новый API */
let alpha = FileA.a;
let beta = FileA.b;
```

Такой код "копирует" fileA

```reason
/* fileA.re. Компилируется как FileA */
let a = 1;
let b = 2;

/* fileB.re */
/* Компилируется как fileA без оверхеда */
include FileA;
```

Сигнатуры (Signatures)
----------------------------------

Тип модуля называется "сигнатурой" и может быть указан явно. Если исплементация
модуля в файле `.re`, то его сигнатура помещается в файл `.rei`.

#### Создание

Для создания сигнатуры используется ключевое слово `module type`. Имя сигнатуры
должно начинаться с **заглавной буквы**. Все что может находиться в файле `.rei`
также может находиться в блоке `{}`.

```reason
/* Учитывая код предыдущих примеров */
module type EstablishmentType = {
  type profession;
  let getProfession: profession => string;
};
```

Сигнатура определяет список требований, которым модуль должен удовлетворять для
того, чтобы соответствовать сигнатуре. Эти требования имеют форму:

- `let x: int;` требует `let` привязки, с именем `x` и типом `int`.

- `type t = someType;` требует, чтобы тип `t` был эквивалентен типу `someType`.

- `type t;` требует наличия типа `t`, но не требует конкретной реализации типа
  `t`. Мы можем использовать `t` в других частях сигнатуры для того, чтобы
  описывать связи. Например, `let makePair: t -> (t, t)`. Это дает нам хороший
  способ абстракции.

Для иллюстрации разных типов записи, возьмем следующую сигнатуру
`EstablishmentType`, которая требует от модуля:

- Объявить переменную `profession`.
- Объявить функцию, которая принимает аргумент типа `profession` и возвращает
  строку.

**Важно:**:

Модуль типа `EstablishmentType` может содержать больше полей, чем объявляет
сигнатура, как, например, модуль `School` в предыдущем примере (если мы применим
его к типу `EstablishmentType`. В противном случае модуль `School` сделает
доступными все поля). Это делает поле `person1` скрытой деталью реализации.
К нему нельзя получить доступ снаружи, так как его нет в сигнатуре.
Таким образом сигнатура **ограничивает** доступ из других модулей.

Тип `EstablishmentType.profession` является **абстрактным**: он не содержит
конкретный тип. Он как будто говорит "Мне не важно какой тип внутри, а важно, что
он используется как аргумент для `getProfession`". Это полезно, когда нужно
уместить несколько модулей за одним интерфейсом.

```reason
module Company: EstablishmentType = {
  type profession = CEO | Designer | Engineer | ...;

  let getProfession person => ...
  let person1 = ...;
  let person2 = ...;
};
```

Это так же полезно, когда нужно спрятать внутренний тип как деталь реализации.
Если вы спросите у компилятора тип `Company.profession` он не покажет вариант,
а просто скажет, что это `Company.profession`.

#### Каждый `.rei` файл является сигнатурой

Так же как файл `react.re` скрыто определяет модуль `React`, файл `react.rei`
скрыто определяет сигнатуру `React`. Если `react.rei` не задан, то по умолчанию
сигнатура `react.re` делает доступными все поля модуля.
Так как `.rei.` файлы не содержат деталей реализации, они часто используются как
документация публичного API для соответствующих модулей.


```reason
/* Файл react.re (реализаци. Компилируется в модуль React) */
type state = int;
let render = fun str => str;
```

```reason
/* Файл react.rei (интерфейс. Компилируется в сигнатуру React) */
type state = int;
let render: str => str;
```

Модули-функции (функторы)
----------------------------------

Модули могут быть переданы как аргументы функции. Однако, модули являются
другим "слоем" языка нежели остальные сущности. Поэтому мы не можем передать их
в **обычные** функции. Вместо этого мы можем передать их в специальный функции,
называемые функторами.

Синтаксис объявления и использования функторов похож на синтаксис обычных функций.
Основные отличия:

- Функторы используют ключевое слово `module`
- Функтор принимает модуль и возвращает модуль
- Функтор *требует* аннотации аргументов
- Имя функтора должно начинаться с большой буквы

Вот пример функтора `MakeSet`, который получает модуль типа `Comparable`
и возвращает модуль, который может работать с такими "сравниваемыми" элементами.

```reason
module type Comparable = {
  type t;
  let equal: t => t => bool;
};

module MakeSet = fun (Item: Comparable) => {
  /* используем список как основу */
  type backingType = list Item.t;
  let empty = [];
  let add (currentSet: backingType) (newItem: Item.t) :backingType =>
    /* если элемент существует */
    if (List.exists (fun x => Item.equal x newItem) currentSet) {
      currentSet /* возвращаем тот же самый список */
    } else {
      [newItem, ...currentSet]; /* добавляем в начало списка и возвращаем */
    }
};
```

Функторы применяются так же как и функции. В данном случае мы создаем набор,
в котором элементы являются парами целых чисел:

```reason
module IntPair = {
  type t = (int, int);
  let equal (x1, y1) (x2, y2) => x1 == x2 && y1 == y2;
  let create x y => (x, y);
};

module SetOfIntPairs = MakeSet IntPair;
```

#### Типы функторов

Как и в случае с типами модулей, типы функторов скрывают детали реализации.
Синтаксис такой же как у типов функций, только имена начинаются с заглавной
буквы. В предыдущем примере мы давали доступ к внутреннему типу (list) набора.
Дав функтору `MakeSet` сигнатуру, мы можем спрятать внутренний тип!
Like with module types, functor types also act to constrain and hide what we may

```reason
module type Comparable = ...

module type MakeSetType = (Item: Comparable) => {
  type backingType;
  let empty: backingType;
  let add: backingType => Item.t => backingType;
};

module MakeSet: MakeSetType = fun (Item: Comparable) => {
  ...
};
```

Минусы
----------------------------------

Модули и функторы являются отдельным "слоем" языка. Например, вы не можете
передать их в кортеж или запись. Используйте их с умом. В большинстве случаем
записи или функции будет достаточно.

```reason
module School = {...};

/* ошибка синтаксиса */
let schools = (School, School);
```
