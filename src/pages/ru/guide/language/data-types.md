---
title: Встроенные типы данных
order: 2
---

### Кортеж (Tuple)

Кортеж является

- неизменяемым
- упорядоченным
- имеющим фиксированный размер
- гетерогенным

```reason
let myThreeFloats = (20.0, 30.0, 100.0);
let myIntAndString = (20, "totallyNotAnInteger");
```

Кортежи могут быть использованы в аннотациях. Кортежи-типы визуально похожи
на кортежи-значения.

```reason
let myThreeFloats: (float, float, float) = (20.0, 30.0, 100.0);
/* псевдоним кортежа-типа */
type myPair = (int, string);
let myIntAndString: myPair = (20, "totallyNotAnInteger");
```

**Важно**: нельзя создать кортеж с один элементом

### Запись (Record)

Записи — это наборы именованных значений. Они напоминают "объекты", но являются
- легкими
- неизменяемыми по умолчанию
- менее гибкими
- более быстрыми

```reason
type person = {age: int, name: string}; /* тип */
let me = {age: 30, name: "Jordan"}; /* значение */
print_string me.name; /* доступ к полю */
```

**Важно**: Записи обязаны иметь определение типа

Новый записи могут быть созданы из старых при помощи `...` оператора (spread operator).
Начальная запись изменена не будет.

```reason
let meNextYear = {...me, age: me.age + 1};
```

**Важно**: описанным выше способом нельзя добавить новые поля

##### Синтаксический сахар

Чтобы уменьшить избыточность, мы предоставили **punning** для типов и значений записей.
Вы можете использовать это, когда имя поля записи эквивалентно имени переменной/типа.

```reason
type horsePower = {power: int, metric: bool};

let metric = true;
let horsePower1 = {power: 10, metric};
/* эквивалентно значению {power: 10, metric: metric}; */

type car = {name: string, horsePower};
/* эквивалентно типу {name: string, horsePower: horsePower}; */
```

**Важно**: это не работает для случая с одним полем! `{foo}` делает не то, что вы ожидаете
(это блок, который возвращает значение `foo`).

##### Изменяемые поля

Поле записи можно сделать изменяемым. Это позволяет изменять такие поля используя
оператор `=`.

```reason
type person = {
  name: string,
  mutable age: int
};
let me = {name: "Jordan", age: 30};
me.age = me.age + 1; /* изменяет `me`. Happy birthday! */
```

### Вариант

Обычно структуры данных описывают "это" **и** "то". Вариант позволяет выразить
"это" **или** "то".

```reason
type response =
| Yes
| No
| PrettyMuch;

let areYouCrushingIt = Yes;
```

`Yes`, `No` и `PrettyMuch` — это не строки, не ссылки и не какие либо специальные типы данных.
Они называются "конструкторы" (или "теги"). Символ `|` разделяет каждый конструктор.

**Важно**: конструкторы вариантов всегда начинаются с заглавной буквы.

Конструкция `switch` похожа на большой `if/elseif/elseif..` который позволяет проверить
все возможные значения варианта. Для использования перечислите все конструкторы,
поставив после каждого `=>` и значение соответствующее конструктору.


```reason
let message = switch (areYouCrushingIt) {
| No => "No worries. Keep going!"
| Yes => "Great!"
| PrettyMuch => "Nice!"
};
/* message равно "Great!" */
```

Компилятор покажет ошибку, если вы забудете указать один из случаев или два
случая взаимоисключаемы.

##### Аргументы конструктора

Конструктор может получить дополнительные данные, указанные через пробел.

```reason
type account =
| None
| Instagram string
| Facebook string int;
```

В этом случае `Instagram` требует строку, а `Facebook` строку и целое число.
Используются следующим образом:

```reason
let myAccount = Facebook "Josh" 26;
let friendAccount = Instagram "Jenny";
```

**Обратите внимание**, что использование конструктора похоже на вызов функции!
Это как если бы `Facebook` был функцией принимающей два аргумента.
Это не случайность, что данные для конструктора называются аргументами.

**Важно**: не путайте конструктор, который использует два аргумента с конструктором,
который использует кортеж из двух элементов:

```reason
type account =
| Facebook string int /* 2 аргумента */
type account2 =
| Instagram (string, int) /* один аргумент - кортеж */
```

##### Использование switch с аргументами конструктора

Выражение `switch` позволяет "открывать" вариант и давать его аргументам имена.

```reason
type account =
| None
| Instagram string;
| Facebook string int
let myAccount = Facebook "Josh" 26;
...
let greeting = switch (myAccount) {
| None => "Hi!"
| Facebook name age =>
  "Hi " ^ name ^ ", you're " ^ (string_of_int age) ^ "-year-old."
| Instagram name => "Hello " ^ name ^ "!"
}
```

Это называется паттерн-матчинг (pattern-matching). Это более мощная версия
деструктурирования, которое есть в других языках.


### Связанный список (Linked List)

Списки гомогенны, неизменяемы и поддерживают быстрое `O(1)` добавление в начало.

```reason
let myList = [1, 2, 3];
let anotherList = [0, ...myList]; /* переменная myList не изменилась */
```

Под капотом список это просто вариант, но с простым синтаксисом.
Чтобы проиллюстрировать это, вот способ создать собственный тип списка, не
используя короткий синтаксис.

```reason
type myListType = Empty | NonEmpty int myListType;
let myList = NonEmpty 1 (NonEmpty 2 (NonEmpty 3 Empty));
/* тоже что и [1, 2, 3] */
```

### Массив

Массивы похожи на списки за исключением того, что они изменяемы и предоставляют
быстрый случайный доступ для случаев, когда производительность важна.

```reason
let myArray = [|"hello", "world", "how are you"|];
let world = myArray.(1);
Array.set myArray 0 "hey";
/* [|"hey", "world", "how are you"|] */
```
