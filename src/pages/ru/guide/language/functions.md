---
title: Функции
order: 3
---

Функции объявляются при помощи ключевого слова `fun` и возвращают выражение.

```reason
let greet = fun name => "Hello " ^ name;
```

Этот код объявляет функцию и присваивает ее переменной `greet`, которую вы можете
вызвать следующим образом:

```reason
greet "world!"; /* "Hello world!" */
```

Несколько аргументов разделяются пробелами:

```reason
let add = fun x y z => x + y + z;
add 1 2 3; /* 6 */
```

Для длинных функций тело оборачивается в блок:

```reason
let greetMore = fun name => {
  let part1 = "Hello";
  part1 ^ " " ^ name
};
```

**Так как функции приходится объявлять часто**, мы предлагаем `let + fun` сокращение:

```reason
let add x y z => x + y + z;
/* same as: let add = fun x y z => x + y + z; */
```

**Будте аккуратны с порядком вызова**! Иногда нужно оборачивать вызов в скобки:

```reason
let increment x => x + 1;
let double x => x + x;

let eleven = increment (double 5);
```

Если вы забудете обернуть `double 5` в скобки, то получите `increment double 5`,
и функция `increment` получит два аргумента.

#### Без аргументов

Функция всегда получает аргумент Но иногда мы используем ее для сторонних эффектов
и не нуждаемся в аргументах. В других языках мы просто не передаём аргументы. В Reason
в таких случаях мы передаём `()` — юнит (unit).

```reason
/* функция получает юнит аргумент */
let logSomething () => {
  print_endline "hello";
  print_endline "world";
};

/* вызов функции, чей аргумент — юнит тип */
logSomething ();
```

`()` это вполне нормальное значение, единственно для типа `unit`. Reason/OCaml представляет специальный синтаксис для удобства.

#### Именованные аргументы

Функции с несколькими аргументами, особенно те, в которых аргументы одного типа, могут запутать.

```reason
let addCoordinates x y => {
  /* x и y используются здесь */
};
...
addCoordinates 5 6; /* какой из них x, а какой y? */
```

В OCaml/Reason, вы можете указать имя аргумента:

```reason
let addCoordinates x::x y::y => {
  /* x и y используются здесь */
};
...
addCoordinates x::5 y::6;
```

Так как у нас есть каррирование (подробнее [тут](#diving-deeper-more-on-function))
мы можем указывать переменные в любом порядке.

```reason
addCoordinates y::6 x::5;
```

`x::x` в объявлении означает, что функция принимает переменную с меткой `x`,
на которую можно ссылаться внутри тела функции по имени `x`. Так же это можно использовать для переименования аргументов.

```reason
let drawCircle radius::r color::c => {
  setColor c;
  startAt r r;
  ...
};

drawCircle radius::10 color::"red";
```


Для стандартного случая `radius::radius` (когда метка равна имени переменной),
мы используем короткий синтаксис `::x`:

```reason
let drawCircle ::radius ::color => {
  setColor color;
  startAt radius radius;
  ...
}
```

А вот так можно указать типы:

```reason
let drawCircle radius::(r: int) color::(c: string) => ...;
```

#### Опциональные именованные аргументы

Именованные аргументы можно пометить как опциональные. При вызове можно их не указывать.

```reason
/* radius можно не указывать */
let drawCircle ::color ::radius=? () => {
  setColor color;
  switch radius {
  | None => startAt 1 1;
  | Some r_ => startAt r_ r_;
  }
};
```

`radius` **обернут** в стандартный тип `option`, и по умолчанию равен `None`.
Если значение указано, то он будет обернут в значение `Some`. Поэтому в данном случае
значение радиуса или `None` или `Some int`.

**Важно**: `None | Some foo` — это структура данных, называемая вариант, и описанная [выше](./#built-in-data-types-variant). Этот конкретный тип варианта предоставлен стандартной библиотекой. Называется `option`. Определение: `type option 'a = None | Some 'a`.

**Обратите внимение**, на юнит `()` в конце `drawCircle`. Без него непонятно что означает следующее:

```reason
let whatIsThis = drawCircle ::color;
```

Является ли `whatIsThis` каррированой версией функции `drawCircle` ожидающей
опционального аргумента `radius`? Или это результат вызова с аргументов по умолчанию?
Чтобы избежать путаницы добавьте неименованный аргумент (обычно `()`),
и OCaml будет считать, что именованный аргумент опущен.

```reason
let curriedFunction = drawCircle ::color;
let actualResultWithoutProvidingRadius = drawCircle ::color ();
```

##### Явно переданные опциональные аргументы

Иногда вы хотите передать значение в функцию, не проверяя является ли оно
`None` или `Some a`. Наивный подход:

```reason
let result = switch payloadRadius {
| None => drawCircle ::color ()
| Some r => drawCircle ::color radius::r ()
};
```

Это быстро надоедает. Есть короткая запись:

```reason
let result = drawCircle ::color radius::?payloadRadius ();
```

Это означает "я понимаю, что `radius` опционален, и что если я передам значение, то оно должно быть типа `int`,
но я не знаю какое значение я передаю `None` или `Some val`, поэтому я передам `option`".

##### Опциональные параметры со значением по умолчанию

Опциональные именованные аргументы могут использовать значение по умолчанию.
Они не будут обернуты в тип `option`.

```reason
let drawCircle ::radius=1 ::color () => {
  setColor color;
  startAt r r;
};
```
