---
title: Interop
order: 1
---

## Just dumping JavaScript in the middle of your Reason code

If you're just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code ðŸ˜„.

```ocaml
Js.log "this is reason";
[%%bs.raw {|
console.log('here is some javascript for you');
|}];
```

> `{|` and `|}` are the delimiters of a multi-line string in OCaml. You can also put a tag in there e.g. `{something|` and then it will look for a matching `|something}` to close.

And here's the resulting javascript:

```javascript
// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';
console.log("this is reason");
console.log('here is some javascript for you');
```

## Dumping in some JavaScript, and making it accessible from Reason

What if you want a value that can be used from your Reason code?

```ocaml
Js.log "this is reason";
let x = [%bs.raw {| 'here is a string from javascript' |}];
Js.log (x ^ " back in reason land"); /* ^ is the operator for string concat */
```

Now you might be wondering "what magic is this?? How did ocaml know that `x` was a string? **It doesn't**. The type of `x` in this code is a magic type that will unify with anything! This is quite dangerous and can have cascading effects in OCaml's type inference algorithm.

```ocaml
let y = [%bs.raw {| 'something' |}];
Js.log ("a string" ^ y, 10 + y);
/* danger!! ocaml won't stop you from using y as 2 totally different types */
```

To fix this, you should **always** provide a concrete type for the result of `bs.raw`.

```ocaml
let x: string = [%bs.raw {| 'well-typed' |}];
Js.log (x ^ " back in reason land");
/* ocaml will error out if you try to use x as anything other than a string */
```

And here's the output!

```javascript
// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
'use strict';
console.log("this is reason");
var x = ( 'here is a string from javascript' );
console.log(x + " back in reason land");
var y = ( 'something' );
console.log(/* tuple */[
      "a string" + y,
      10 + y | 0
    ]);
var x$1 = ( 'well-typed' );
console.log(x$1 + " back in reason land");
```

> The difference between the 2 `%%` from the previous section and the 1 `%` here is important! `[%%something ...]` is an OCaml "extension point" that represents a *top-level* statement (it can't show up inside a function or value, for example). `[%something ...]` is an extension point that stands in for an *expression*, and can be put just about anywhere -- but make sure that the JavaScript you put inside is actually an expression! E.g. don't put a semicolon after it, or you'll get a syntax error when you try to run the resulting JavaScript.

## Dumping in a function & passing values

We'll need a little knowledge about Bucklescript's runtime representation of various values for this to work.

- `strings` are strings, `ints` and `floats` are just numbers
- an [Array](http://facebook.github.io/reason/#built-in-data-types-array) is a mutable fixed-length list in OCaml, and is represented as a plain javascript array.
- a [List](http://facebook.github.io/reason/#built-in-data-types-linked-list) is an immutable functional-style linked list, and is definitely the more idiomatic one to use in most cases. However, it's representation is more complicated (try `Js.log [1,2,3,4]` to check it out). Because of this, I generally convert to & from `Array`s when I'm talking to javascript, via `Array.of_list` and `Array.to_list`.
- If you want to go deeper, there's an exhaustive list [on the BuckleScript wiki](https://github.com/bucklescript/bucklescript/wiki/Runtime-representation)

Knowing that, we can write a function in JavaScript that just accepts an array and returns a number, without much trouble at all.

```ocaml
let jsCalculate: array int => int => int = [%bs.raw {|
 function (numbers, scaleFactor) {
   var result = 0;
   numbers.forEach(number => {
     result += number;
   });
   return result * scaleFactor;
 }
|}];
let calculate numbers scaleFactor =>
  jsCalculate (Array.of_list numbers) scaleFactor;
Js.log (calculate [1,2,3] 10); /* -> 60 */
```

Of course, this function that I wrote in JavaScript could be ported over to Reason without much hassle.

**Remember** that this is an escape hatch that's very useful for learning so you can jump in quickly and make something, but it's a good exercise to go back through and convert things back into nice type safe reason code.

I've run into more than a few bugs because of raw JavaScript that I added to save time ðŸ˜….

## Settling down and getting disciplined about things

So far we've been using `bs.raw`, which is a very fast n loose way to do it, and **not** suitable for production.

But what if we actually need to call a function that's in JavaScript? It's needed for interacting with the DOM, or using node modules. In BuckleScript, you use an `external` declaration ([docs](http://bucklescript.github.io/bucklescript/Manual.html#_binding_to_simple_js_functions_values)).

Getting a value and getting a function are both pretty easy:

```ocaml
external pi: float = "Math.PI" [@@bs.val];
let tau = pi *. 2.0;
external alert: string => void = "alert" [@@bs.val];
alert "hello";
```

But what about when we want something more complicated? Here's how we could call `getContext` on a Canvas DOM node:



```ocaml
type canvas;
type context;
/* we're leaving these types abstract, because we won't
 * be using them directly anywhere */
external getContext: canvas => string => context = "" [@@bs.send];
let myCanvas: canvas = [%bs.raw {| document.getElementById("mycanvas") |}];
let ctx = getContext myCanvas "2d";
```

So let's unpack what's going on. We created some abstract types for the Canvas DOM node and the associated RenderingContext object.

Then we made a `getContext` function, but instead of `@@bs.val` we used `@@bs.send`, and we used an empty string for the text of the external. `@@bs.send` means "we're calling a method on the first argument", which in this case is the canvas. BuckleScript will translate this into `theFirstArgument.getContext(theSecondArgument, ...)`.

And the empty string means "the js-name is the same as the name we're giving the external here in BuckleScript-land", in this case `getContext`. If we wanted to name it something else (like `getRenderingContext`), when we'd have to supply the string `"getContext"` so that BuckleScript calls the right function.

Let's add one more function just so it's interesting.

```ocaml
external fillRect: context => float => float => float => float => unit = "" [@@bs.send];
```

And now we can draw something!

```ocaml
fillRect ctx 0.0 0.0 100.0 100.0;
```

It's not much, but adding other canvas methods is similar, and then you can start doing some [really fun things](https://twitter.com/jaredforsyth/status/871062358076030976).

So what does the compiled JavaScript look like?

```javascript
'use strict';
var tau = Math.PI * 2.0;
alert("hello");
var myCanvas = ( document.getElementById("mycanvas") );
var ctx = myCanvas.getContext("2d");
ctx.fillRect(0.0, 0.0, 100.0, 100.0);
```

Wow! Notice how BuckleScript just inlined our `pi` variable for us? And the output looks almost exactly like it was written by hand.
