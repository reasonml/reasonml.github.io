webpackJsonp([212],{"./node_modules/json-loader/index.js!./.cache/json/api-scanf-html.json":function(e,c){e.exports={data:{file:{relativePath:"api/Scanf.html",childRawHtml:{content:'<div class="ocamldoc">\n<div class="navbar"><a class="pre" href="Random.html" title="Random">Previous</a>\n&#xA0;<a class="up" href="index.html" title="Index">Up</a>\n&#xA0;<a class="post" href="Set.html" title="Set">Next</a>\n</div>\n<h1>Module <a href="type_Scanf.html">Scanf</a></h1>\n\n<pre><span class="keyword">module</span> Scanf: sig .. end</pre><div class="info module top">\nFormatted input functions.<br>\n</div>\n<hr width="100%">\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Asimpleexample">A simple example</div><br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Asimpleexample">A simple example</div><br>\n<br>\nAs suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal\n    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.\n<p>\n\n    For instance,\n</p><p>\n</p><ul>\n<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is\n    the predefined formatted input channel that reads from standard input),</li>\n</ul>\n<ul>\n<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>\n</ul>\n\n    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the\n    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we\n    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the\n    keyboard, we get <code class="code">42</code> as the final result.<br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Asimpleexample">A simple example</div><br>\n<br>\nAs suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal\n    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.\n<p>\n\n    For instance,\n</p><p>\n</p><ul>\n<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is\n    the predefined formatted input channel that reads from standard input),</li>\n</ul>\n<ul>\n<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>\n</ul>\n\n    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the\n    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we\n    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the\n    keyboard, we get <code class="code">42</code> as the final result.<br>\n<br>\n<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Asimpleexample">A simple example</div><br>\n<br>\nAs suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal\n    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.\n<p>\n\n    For instance,\n</p><p>\n</p><ul>\n<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is\n    the predefined formatted input channel that reads from standard input),</li>\n</ul>\n<ul>\n<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>\n</ul>\n\n    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the\n    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we\n    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the\n    keyboard, we get <code class="code">42</code> as the final result.<br>\n<br>\n<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>\n<br>\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\n    However, it is also largely different, simpler, and yet more powerful:\n    the formatted input functions are higher-order functionals and the\n    parameter passing mechanism is just the regular function application not\n    the variable assignment based mechanism which is typical for formatted\n    input in imperative languages; the OCaml format strings also feature\n    useful additions to easily define complex tokens; as expected within a\n    functional programming language, the formatted input functions also\n    support polymorphism, in particular arbitrary interaction with\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\n    facility is fully type-checked at compile time.<br>\n<br>\n<h6 id="6_Introduction">Introduction</h6><br>\n<br>\n<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>\n<br>\nThe module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.\n<p>\n\n    The formatted input functions can read from any kind of input, including\n    strings, files, or anything that can return characters. The more general\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general\n    formatted input function reads from any scanning buffer and is named\n    <code class="code">bscanf</code>.\n</p><p>\n\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\n<li>the first argument is a source of characters for the input,</li>\n<li>the second argument is a format string that specifies the values to\n      read,</li>\n<li>the third argument is a <em>receiver function</em> that is applied to the\n      values read.</li>\n</ul>\n\n    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is\n    <code class="code">bscanf ic fmt f</code>, where:\n<p>\n</p><ul>\n<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">fmt</code> is a format string (the same format strings as those used to print\n    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>\n</ul>\n<ul>\n<li><code class="code">f</code> is a function that has as many arguments as the number of values to\n    read in the input.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Asimpleexample">A simple example</div><br>\n<br>\nAs suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal\n    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.\n<p>\n\n    For instance,\n</p><p>\n</p><ul>\n<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is\n    the predefined formatted input channel that reads from standard input),</li>\n</ul>\n<ul>\n<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>\n</ul>\n\n    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the\n    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we\n    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the\n    keyboard, we get <code class="code">42</code> as the final result.<br>\n<br>\n<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>\n<br>\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\n    However, it is also largely different, simpler, and yet more powerful:\n    the formatted input functions are higher-order functionals and the\n    parameter passing mechanism is just the regular function application not\n    the variable assignment based mechanism which is typical for formatted\n    input in imperative languages; the OCaml format strings also feature\n    useful additions to easily define complex tokens; as expected within a\n    functional programming language, the formatted input functions also\n    support polymorphism, in particular arbitrary interaction with\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\n    facility is fully type-checked at compile time.<br>\n<br>\n<h6 id="6_Formattedinputchannel">Formatted input channel</h6><br>\n\n<pre><span class="keyword">module</span> Scanning: sig .. end</pre><br>\n<h6 id="6_Typeofformattedinputfunctions">Type of formatted input functions</h6><br>\n\n<pre><span class="keyword">type</span> scanner &apos;a &apos;b &apos;c &apos;d = Pervasives.format6 &apos;a Scanning.in_channel &apos;b &apos;c (&apos;a =&gt; &apos;d) &apos;d =&gt; &apos;c;\n</pre>\n<div class="info ">\nThe type of formatted input scanners: <code class="code">(&apos;a, &apos;b, &apos;c, &apos;d) scanner</code>\n    is the type of a formatted input function that reads from some\n    formatted input channel according to some format string; more\n    precisely, if <code class="code">scan</code> is some formatted input function, then <code class="code">scan\n    ic fmt f</code> applies <code class="code">f</code> to the arguments specified by the format\n    string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments from the\n    formatted input channel <code class="code">ic</code>.\n<p>\n\n    For instance, the <code class="code">scanf</code> function below has type <code class="code">(&apos;a, &apos;b, &apos;c, &apos;d)\n    scanner</code>, since it is a formatted input function that reads from\n    <code class="code">Scanning.stdin</code>: <code class="code">scanf fmt f</code> applies <code class="code">f</code> to the arguments specified by\n    <code class="code">fmt</code>, reading those arguments from <code class="code">Pervasives.stdin</code> as expected.\n</p><p>\n\n    If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding input\n    functions must be provided before the receiver <code class="code">f</code> argument. For\n    instance, if <code class="code">read_elem</code> is an input function for values of type <code class="code">t</code>,\n    then <code class="code">bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code class="code">v</code> of type <code class="code">t</code> followed\n    by a <code class="code">&apos;;&apos;</code> character, and returns <code class="code">f v</code>.<br>\n<b>Since</b> 3.10.0<br>\n</p></div>\n\n\n<pre><span class="keyword">exception</span> Scan_failure string;\n</pre>\n<div class="info ">\nThe exception that formatted input functions raise when the input cannot\n    be read according to the given format.<br>\n</div>\n<br>\n<h6 id="6_Thegeneralformattedinputfunction">The general formatted input function</h6><br>\n\n<pre><span class="keyword">let</span> bscanf: Scanning.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\n<code class="code">bscanf ic fmt r1 ... rN f</code> reads arguments for the function <code class="code">f</code>, from the\n    formatted input channel <code class="code">ic</code>, according to the format string <code class="code">fmt</code>, and\n    applies <code class="code">f</code> to these values.\n    The result of this call to <code class="code">f</code> is returned as the result of the entire\n    <code class="code">bscanf</code> call.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun s i -&gt; i + 1</code>, then\n    <code class="code">Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the\n    argument corresponding to the <code class="code">%r</code> conversions specified in the format\n    string.<br>\n</p></div>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="indication">Scanning indications in format strings</div><br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="indication">Scanning indications in format strings</div><br>\n<br>\nScanning indications appear just after the string conversions <code class="code">%s</code>\n    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning\n    indication is introduced by a <code class="code">@</code> character, followed by some\n    plain character <code class="code">c</code>. It means that the string token should end\n    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>\n    character is encountered, the string token spreads as much as\n    possible. For instance, <code class="code">&quot;%s@\\t&quot;</code> reads a string up to the next\n    tab character or to the end of input. If a <code class="code">@</code> character appears\n    anywhere else in the format string, it is treated as a plain character.\n<p>\n\n    Note:\n</p><p>\n</p><ul>\n<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped\n    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications\n    and scanning indications.\n    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>\n<li>The scanning indications introduce slight differences in the syntax of\n    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>\n    module. However, the scanning indications are similar to those used in\n    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned\n    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the\n    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish\n    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>\n    characters).</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="indication">Scanning indications in format strings</div><br>\n<br>\nScanning indications appear just after the string conversions <code class="code">%s</code>\n    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning\n    indication is introduced by a <code class="code">@</code> character, followed by some\n    plain character <code class="code">c</code>. It means that the string token should end\n    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>\n    character is encountered, the string token spreads as much as\n    possible. For instance, <code class="code">&quot;%s@\\t&quot;</code> reads a string up to the next\n    tab character or to the end of input. If a <code class="code">@</code> character appears\n    anywhere else in the format string, it is treated as a plain character.\n<p>\n\n    Note:\n</p><p>\n</p><ul>\n<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped\n    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications\n    and scanning indications.\n    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>\n<li>The scanning indications introduce slight differences in the syntax of\n    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>\n    module. However, the scanning indications are similar to those used in\n    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned\n    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the\n    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish\n    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>\n    characters).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="indication">Scanning indications in format strings</div><br>\n<br>\nScanning indications appear just after the string conversions <code class="code">%s</code>\n    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning\n    indication is introduced by a <code class="code">@</code> character, followed by some\n    plain character <code class="code">c</code>. It means that the string token should end\n    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>\n    character is encountered, the string token spreads as much as\n    possible. For instance, <code class="code">&quot;%s@\\t&quot;</code> reads a string up to the next\n    tab character or to the end of input. If a <code class="code">@</code> character appears\n    anywhere else in the format string, it is treated as a plain character.\n<p>\n\n    Note:\n</p><p>\n</p><ul>\n<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped\n    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications\n    and scanning indications.\n    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>\n<li>The scanning indications introduce slight differences in the syntax of\n    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>\n    module. However, the scanning indications are similar to those used in\n    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned\n    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the\n    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish\n    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>\n    characters).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>\n<br>\nScanners may raise the following exceptions when the input cannot be read\n    according to the format string:\n<p>\n</p><ul>\n<li>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more\n      characters are needed to read the current conversion specification.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</li>\n</ul>\n\n    Note:\n<p>\n</p><ul>\n<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception\n    <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and\n    simply returns the characters read so far, or <code class="code">&quot;&quot;</code> if none were ever read.</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Formatstringdescription">Format string description</h6><br>\n<br>\nThe format string is a character string which contains three types of\n    objects:<ul>\n<li>plain characters, which are simply matched with the characters of the\n      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>conversion specifications, each of which causes reading and conversion of\n      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>\n<li>scanning indications to specify boundaries of tokens\n      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="space">The space character in format strings</div><br>\n<br>\nAs mentioned above, a plain character in the format string is just\n    matched with the next character of the input; however, two characters are\n    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code\n    32) and the line feed character (<code class="code">&apos;\\n&apos;</code> or ASCII code 10).\n    A space does not match a single space character, but any amount of\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\n    string matches <em>any number</em> of tab, space, line feed and carriage\n    return characters. Similarly, a line feed character in the format string\n    matches either a single line feed or a carriage return followed by a line\n    feed.\n<p>\n\n    Matching <em>any</em> amount of whitespace, a space in the format string\n    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an\n    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,\n    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>\n<br>\n</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>\n<br>\nConversion specifications consist in the <code class="code">%</code> character, followed by\n    an optional flag, an optional field width, and followed by one or\n    two conversion characters. The conversion characters and their\n    meanings are:\n<p>\n</p><ul>\n<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>\n<li><code class="code">i</code>: reads an optionally signed integer\n      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal\n       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary\n       (<code class="code">0b[0-1]+</code>) notations are understood).</li>\n<li><code class="code">u</code>: reads an unsigned decimal integer.</li>\n<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>\n<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>\n<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the\n      following bounding condition holds: <ul>\n<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>\n<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been\n         encountered,</li>\n<li>the end-of-input has been reached.</li>\n</ul>\n\n      Hence, this conversion always succeeds: it returns an empty\n      string if the bounding condition holds when the scan begins.</li>\n<li><code class="code">S</code>: reads a delimited string argument (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">c</code>: reads a single character. To test the current input character\n      without reading it, specify a null field width, i.e. use\n      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width\n      specification is greater than 1.</li>\n<li><code class="code">C</code>: reads a single delimited character (delimiters and special\n      escaped characters follow the lexical conventions of OCaml).</li>\n<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed\n      floating-point number in decimal notation, in the style <code class="code">dddd.ddd\n      e/E+-dd</code>.</li>\n<li><code class="code">F</code>: reads a floating point number according to the lexical\n      conventions of OCaml (hence the decimal point is mandatory if the\n      exponent part is not mentioned).</li>\n<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>\n<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use\n      in new programs).</li>\n<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to\n      the format specified by the second letter for regular integers.</li>\n<li><code class="code">[ range ]</code>: reads characters that matches one of the characters\n      mentioned in the range of characters <code class="code">range</code> (or not mentioned in\n      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be\n      empty, if the next input character does not match the range. The set of\n      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.\n      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number\n      or an empty string if no decimal digit is found; similarly,\n      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.\n      If a closing bracket appears in a range, it must occur as the\n      first character of the range (or just after the <code class="code">^</code> in case of\n      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and\n      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.\n      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>\n<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input\n      function and applies it to the scanning buffer <code class="code">ib</code> to read the\n      next argument. The input function <code class="code">ri</code> must therefore have type\n      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>\n<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string\n      read must have the same type as the format string specification\n      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that\n      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string\n      <code class="code">&quot;fmt:\\&quot;number is %u\\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\n      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>\n<li><code class="code">( fmt %)</code>: scanning sub-format substitution.\n      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with\n      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.\n      The format string <code class="code">rf</code> must have the same type as the format string\n      specification <code class="code">fmt</code> that it replaces.\n      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value\n      of type <code class="code">int</code>.\n      The conversion returns the format string read <code class="code">rf</code>, and then a value\n      read using <code class="code">rf</code>.\n      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then\n      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\n      <code class="code">(&quot;%4d&quot;, 1234)</code>.\n      This behaviour is not mere format substitution, since the conversion\n      returns the format string read as additional argument. If you need\n      pure format substitution, use special flag <code class="code">_</code> to discard the\n      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string\n      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is\n      the string <code class="code">&quot;\\&quot;%4d\\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\n      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\n<li><code class="code">l</code>: returns the number of lines read so far.</li>\n<li><code class="code">n</code>: returns the number of characters read so far.</li>\n<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>\n<li><code class="code">!</code>: matches the end of input condition.</li>\n<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>\n<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>\n<li><code class="code">,</code>: does nothing.</li>\n</ul>\n\n    Following the <code class="code">%</code> character that introduces a conversion, there may be\n    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,\n    but the resulting value is discarded.\n    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the\n    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.\n<p>\n\n    The field width is composed of an optional integer literal\n    indicating the maximal width of the token to read.\n    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;\n    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\\000-\\255]</code>\n    returns the next 8 characters (or all the characters still available,\n    if fewer than 8 characters are available in the input).\n</p><p>\n\n    Notes:\n</p><p>\n</p><ul>\n<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is\n      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>\n</ul>\n<ul>\n<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear\n    inside numbers (this is reminiscent to the usual OCaml lexical\n    conventions). If stricter scanning is desired, use the range\n    conversion facility instead of the number conversions.</li>\n</ul>\n<ul>\n<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical\n    analysis and parsing. If it appears not expressive enough for your\n    needs, several alternative exists: regular expressions (module\n    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,\n    <code class="code">ocamlyacc</code>-generated parsers.</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="indication">Scanning indications in format strings</div><br>\n<br>\nScanning indications appear just after the string conversions <code class="code">%s</code>\n    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning\n    indication is introduced by a <code class="code">@</code> character, followed by some\n    plain character <code class="code">c</code>. It means that the string token should end\n    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>\n    character is encountered, the string token spreads as much as\n    possible. For instance, <code class="code">&quot;%s@\\t&quot;</code> reads a string up to the next\n    tab character or to the end of input. If a <code class="code">@</code> character appears\n    anywhere else in the format string, it is treated as a plain character.\n<p>\n\n    Note:\n</p><p>\n</p><ul>\n<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped\n    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications\n    and scanning indications.\n    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>\n<li>The scanning indications introduce slight differences in the syntax of\n    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>\n    module. However, the scanning indications are similar to those used in\n    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned\n    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the\n    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish\n    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>\n    characters).</li>\n</ul>\n<br>\n<br>\n<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>\n<br>\nScanners may raise the following exceptions when the input cannot be read\n    according to the format string:\n<p>\n</p><ul>\n<li>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more\n      characters are needed to read the current conversion specification.</li>\n</ul>\n<ul>\n<li>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</li>\n</ul>\n\n    Note:\n<p>\n</p><ul>\n<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception\n    <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and\n    simply returns the characters read so far, or <code class="code">&quot;&quot;</code> if none were ever read.</li>\n</ul>\n<br>\n<br>\n<h6 id="6_Specialisedformattedinputfunctions">Specialised formatted input functions</h6><br>\n\n<pre><span class="keyword">let</span> fscanf: Pervasives.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given regular input channel.\n<p>\n\n    Warning: since all formatted input functions operate from a <em>formatted\n    input channel</em>, be aware that each <code class="code">fscanf</code> invocation will operate with a\n    formatted input channel reading from the given channel. This extra level\n    of bufferization can lead to a strange scanning behaviour if you use low\n    level primitives on the channel (reading characters, seeking the reading\n    position, and so on).\n</p><p>\n\n    As a consequence, never mix direct low level reading and high level\n    scanning from the same regular input channel.<br>\n</p></div>\n\n<pre><span class="keyword">let</span> sscanf: string =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given string.<br>\n</div>\n\n<pre><span class="keyword">let</span> scanf: scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the predefined formatted input\n    channel <a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> that is connected to <code class="code">Pervasives.stdin</code>.<br>\n</div>\n\n<pre><span class="keyword">let</span> kscanf: Scanning.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but takes an additional function argument\n    <code class="code">ef</code> that is called in case of error: if the scanning process or\n    some conversion fails, the scanning function aborts and calls the\n    error handling function <code class="code">ef</code> with the formatted input channel and the\n    exception that aborted the scanning process as arguments.<br>\n</div>\n\n<pre><span class="keyword">let</span> ksscanf: string =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALkscanf"><code class="code">Scanf.kscanf</code></a> but reads from the given string.<br>\n<b>Since</b> 4.02.0<br>\n</div>\n\n<pre><span class="keyword">let</span> kfscanf: Pervasives.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALkscanf"><code class="code">Scanf.kscanf</code></a>, but reads from the given regular input channel.<br>\n<b>Since</b> 4.02.0<br>\n</div>\n<br>\n<h6 id="6_Readingformatstringsfrominput">Reading format strings from input</h6><br>\n\n<pre><span class="keyword">let</span> bscanf_format:\n  Scanning.in_channel =&gt;\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\n  &apos;g;\n</pre><div class="info ">\n<code class="code">bscanf_format ic fmt f</code> reads a format string token from the formatted\n    input channel <code class="code">ic</code>, according to the given format string <code class="code">fmt</code>, and\n    applies <code class="code">f</code> to the resulting format string value.\n    Raise <code class="code">Scan_failure</code> if the format string value read does not have the\n    same type as <code class="code">fmt</code>.<br>\n<b>Since</b> 3.09.0<br>\n</div>\n\n<pre><span class="keyword">let</span> sscanf_format:\n  string =&gt;\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\n  &apos;g;\n</pre><div class="info ">\nSame as <a href="Scanf.html#VALbscanf_format"><code class="code">Scanf.bscanf_format</code></a>, but reads from the given string.<br>\n<b>Since</b> 3.09.0<br>\n</div>\n\n<pre><span class="keyword">let</span> format_from_string:\n  string =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f;\n</pre><div class="info ">\n<code class="code">format_from_string s fmt</code> converts a string argument to a format string,\n    according to the given format string <code class="code">fmt</code>.\n    Raise <code class="code">Scan_failure</code> if <code class="code">s</code>, considered as a format string, does not\n    have the same type as <code class="code">fmt</code>.<br>\n<b>Since</b> 3.10.0<br>\n</div>\n\n<pre><span class="keyword">let</span> unescaped: string =&gt; string;\n</pre><div class="info ">\nReturn a copy of the argument with escape sequences, following the\n    lexical conventions of OCaml, replaced by their corresponding\n    special characters. If there is no escape sequence in the\n    argument, still return a copy, contrary to String.escaped.<br>\n<b>Since</b> 4.00.0<br>\n</div>\n</div>'
}}},pathContext:{relativePath:"api/Scanf.html"}}}});
//# sourceMappingURL=path---api-scanf-html-8a3b94e4b6e659d16e80.js.map