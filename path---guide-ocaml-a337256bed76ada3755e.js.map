{"version":3,"sources":["webpack:///path---guide-ocaml-a337256bed76ada3755e.js","webpack:///./.cache/json/guide-ocaml.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json","module","exports","data","allFile","edges","node","relativePath","childMarkdownRemark","frontmatter","title","order","file","html","pathContext","section","sectionTitle","relatedFiles"],"mappings":"AAAAA,cAAc,KAERC,qEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,SACAC,QAEAC,MACAC,aAAA,iBACAC,qBACAC,aACAC,MAAA,mBACAC,MAAA,OAMAL,MACAC,aAAA,oBACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,QAMAL,MACAC,aAAA,iBACAC,qBACAC,aACAC,MAAA,sBACAC,MAAA,QAMAL,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,qBACAC,MAAA,OAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,QAMAL,MACAC,aAAA,gCACAC,qBACAC,aACAC,MAAA,YACAC,MAAA,OAMAL,MACAC,aAAA,8BACAC,qBACAC,aACAC,MAAA,UACAC,MAAA,OAMAL,MACAC,aAAA,8BACAC,qBACAC,aACAC,MAAA,YACAC,MAAA,SAMAL,MACAC,aAAA,wCACAC,qBACAC,aACAC,MAAA,oBACAC,MAAA,OAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,UACAC,MAAA,QAMAL,MACAC,aAAA,kCACAC,qBACAC,aACAC,MAAA,gBACAC,MAAA,SAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,SAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,SAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,UACAC,MAAA,SAMAL,MACAC,aAAA,0BACAC,qBACAC,aACAC,MAAA,kBACAC,MAAA,QAMAL,MACAC,aAAA,qCACAC,qBACAC,aACAC,MAAA,mBACAC,MAAA,SAMAL,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,MACAC,MAAA,SAMAL,MACAC,aAAA,sCACAC,qBACAC,aACAC,MAAA,kBACAC,MAAA,QAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,SAMAL,MACAC,aAAA,gCACAC,qBACAC,aACAC,MAAA,cACAC,MAAA,QAMAL,MACAC,aAAA,mCACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,QAMAL,MACAC,aAAA,2BACAC,qBACAC,aACAC,MAAA,SACAC,MAAA,SAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,SAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,OAMAL,MACAC,aAAA,2BACAC,qBACAC,aACAC,MAAA,SACAC,MAAA,SAMAL,MACAC,aAAA,qCACAC,qBACAC,aACAC,MAAA,oBACAC,MAAA,SAMAL,MACAC,aAAA,yBACAC,qBACAC,aACAC,MAAA,QACAC,MAAA,QAMAL,MACAC,aAAA,2BACAC,qBACAC,aACAC,MAAA,SACAC,MAAA,QAMAL,MACAC,aAAA,0BACAC,qBACAC,aACAC,MAAA,QACAC,MAAA,QAMAL,MACAC,aAAA,oCACAC,qBACAC,aACAC,MAAA,gBACAC,MAAA,QAMAL,MACAC,aAAA,qCACAC,qBACAC,aACAC,MAAA,wBACAC,MAAA,OAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,SACAC,MAAA,QAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,QAMAL,MACAC,aAAA,sCACAC,qBACAC,aACAC,MAAA,gBACAC,MAAA,QAMAL,MACAC,aAAA,wCACAC,qBACAC,aACAC,MAAA,kBACAC,MAAA,QAMAL,MACAC,aAAA,4CACAC,qBACAC,aACAC,MAAA,sBACAC,MAAA,QAMAL,MACAC,aAAA,8BACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,SAOAC,MACAL,aAAA,iBACAC,qBACAK,KAAA;AACAJ,aACAC,MAAA,0BAKAI,aACAC,QAAA,QACAC,aAAA,QACAT,aAAA,iBACAU,aAAA","file":"path---guide-ocaml-a337256bed76ada3755e.js","sourcesContent":["webpackJsonp([14],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"allFile\": {\n\t\t\t\t\"edges\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"The Reason Guide\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/examples.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Examples\",\n\t\t\t\t\t\t\t\t\t\"order\": 60\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Comparison to OCaml\",\n\t\t\t\t\t\t\t\t\t\"order\": 50\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/what-and-why.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"What & Why\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/converting.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Converting from JS\",\n\t\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"JavaScript\",\n\t\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/libraries.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Libraries\",\n\t\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/interop.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Interop\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/exception.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Exception\",\n\t\t\t\t\t\t\t\t\t\"order\": 175\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/syntax-cheatsheet.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Syntax Cheatsheet\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/quickstart.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/boolean.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Boolean\",\n\t\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/destructuring.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Destructuring\",\n\t\t\t\t\t\t\t\t\t\"order\": 130\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/external.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"External\",\n\t\t\t\t\t\t\t\t\t\"order\": 170\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/function.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Function\",\n\t\t\t\t\t\t\t\t\t\"order\": 100\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/if-else.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"If-Else\",\n\t\t\t\t\t\t\t\t\t\"order\": 110\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Language basics\",\n\t\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/imperative-loops.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Imperative Loops\",\n\t\t\t\t\t\t\t\t\t\"order\": 150\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/jsx.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"JSX\",\n\t\t\t\t\t\t\t\t\t\"order\": 160\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/integer-and-float.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Integer & Float\",\n\t\t\t\t\t\t\t\t\t\"order\": 40\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/more-on-type.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"More on Type\",\n\t\t\t\t\t\t\t\t\t\"order\": 120\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/let-binding.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Let Binding\",\n\t\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/list-and-array.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"List & Array\",\n\t\t\t\t\t\t\t\t\t\"order\": 80\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/module.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Module\",\n\t\t\t\t\t\t\t\t\t\"order\": 180\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/mutation.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Mutation\",\n\t\t\t\t\t\t\t\t\t\"order\": 140\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/overview.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Overview\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/object.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Object\",\n\t\t\t\t\t\t\t\t\t\"order\": 175\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/pattern-matching.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Pattern Matching!\",\n\t\t\t\t\t\t\t\t\t\"order\": 135\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/type.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Type!\",\n\t\t\t\t\t\t\t\t\t\"order\": 15\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/record.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Record\",\n\t\t\t\t\t\t\t\t\t\"order\": 60\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/tuple.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Tuple\",\n\t\t\t\t\t\t\t\t\t\"order\": 50\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/string-and-char.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"String & Char\",\n\t\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/convert-from-ocaml.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Converting from OCaml\",\n\t\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/quickstart.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Native\",\n\t\t\t\t\t\t\t\t\t\"order\": 40\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/variant.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Variant!\",\n\t\t\t\t\t\t\t\t\t\"order\": 70\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/extra-goodies.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Extra Goodies\",\n\t\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/editors-plugins.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Editors Plugins\",\n\t\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/global-installation.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Global Installation\",\n\t\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Editor Setup\",\n\t\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"file\": {\n\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\"html\": \"<p>If you come from OCaml or are a newcomer reading a tutorial written on OCaml, this guide's for you! But don't forget that <a href=\\\"https://github.com/reasonml/reason-tools\\\">reason-tools</a> can convert between OCaml and Reason syntax on the fly.</p>\\n<h3 id=\\\"comments\\\"><a href=\\\"#comments\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Comments</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>(* OCaml (*nest*) *)</code></td>\\n<td><code>/* Reason /*nest*/ */</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"operator-renaming\\\"><a href=\\\"#operator-renaming\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Operator Renaming</h3>\\n<p>Reason has all of OCaml's infix operators, but a couple of operators are expressed differently. In Reason, structural equality is written as <code>==</code>, and reference (physical) equality is written as <code>===</code>. In Reason, to achieve the corresponding inequality, simply swap the first character with a <code>!</code> character. (<code>!=</code> for structural inequality, and <code>!==</code> for reference inequality).</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Equality</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Structural</td>\\n<td><code>x = y</code></td>\\n<td><code>x == y</code></td>\\n</tr>\\n<tr>\\n<td>Reference</td>\\n<td><code>x == y</code></td>\\n<td><code>x === y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>Inequality</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Structural</td>\\n<td><code>x &#x3C;> y</code></td>\\n<td><code>x != y</code></td>\\n</tr>\\n<tr>\\n<td>Reference</td>\\n<td><code>x != y</code></td>\\n<td><code>x !== y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"local-scope\\\"><a href=\\\"#local-scope\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Local Scope</h3>\\n<p>Reason's lexical scoping is exactly the same as OCaml's, but let bindings syntactically resemble \\\"block scope\\\" which is more familiar to many developers. In Reason, they are created with <code>{}</code> braces, which may contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>. All blocks evaluate to the last line and the semicolon on the last line is optional. <code>{}</code> braces are only needed if you have more than one item to chain together via <code>;</code>.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet _ =\\n  let msg = \\\"Hello\\\" in\\n  print_string msg;\\n  let msg2 = \\\"Goodbye\\\" in\\n  print_string msg2</pre>\\n    </td>\\n    <td>\\n      <pre>\\n{\\n  let msg = \\\"Hello\\\";\\n  print_string msg;\\n  let msg2 = \\\"Goodbye\\\";\\n  print_string msg2\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p>Reason's <code>{}</code> syntax removes many commonly reported pain points in OCaml's syntax:</p>\\n<ul>\\n<li>Double semicolons are removed entirely.</li>\\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\\n<li>Infamous imperative parsing <a href=\\\"https://github.com/ocaml/ocaml/pull/278\\\">issues</a> are gone.</li>\\n<li>Module bodies and local scope are unified.</li>\\n</ul>\\n<h3 id=\\\"local-scope-vs-module-body\\\"><a href=\\\"#local-scope-vs-module-body\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Local Scope Vs. Module Body</h3>\\n<p>In Reason, everything that can go between the <code>{}</code> in <a href=\\\"#local-scope\\\">Local Scopes</a> and in module bodies. You can usually even cut/paste code between the two contexts. In OCaml, the syntaxes for the two contexts are very different. Local scope requires trailing <code>in</code>, but module bodies do not and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Module Body</p></th><th scope=\\\"col\\\"><p>Reason Module Body</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10\\nlet () = imperativeFunc ten ten\\nlet () = imperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ten = 10;\\nimperativeFunc ten ten;\\nimperativeFunc 0 0;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10;;\\nimperativeFunc ten ten;;\\nimperativeFunc 0 0;;</pre>\\n    </td>\\n    <td>Same as above</td>\\n  </tr>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Local Scope</p></th><th scope=\\\"col\\\"><p>Reason Local Scope</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in\\nlet _ = imperativeFunc ten ten in\\nimperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in begin\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\nend</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in (\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\n)</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"tuple-and-record\\\"><a href=\\\"#tuple-and-record\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Tuple and Record</h3>\\n<p>In Reason, tuples always require parentheses.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let tup = 4, 5</code></td>\\n<td><code>let tup = (4, 5);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tup = ((1: int), (2:int))</code></td>\\n<td><code>let tup = (1: int, 2:int);</code></td>\\n</tr>\\n<tr>\\n<td><code>fun ((a: int), (b: int)) -> a</code></td>\\n<td><code>fun (a: int, b: int) => a;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because Reason tuples always require wrapping parens, records may contain lambdas as values without needing extra parens.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myRec = {x = 0; y = 10}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myRec = {x: 0, y: 10};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n};</pre>\\n    </td>\\n</table>\\n<h3 id=\\\"lists\\\"><a href=\\\"#lists\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lists</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let list = [1; 2; 3]</code></td>\\n<td><code>let list = [1, 2, 3]</code></td>\\n</tr>\\n<tr>\\n<td><code>let list = hd :: tl</code></td>\\n<td><code>let list = [hd, ...tl];</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"type-definitions\\\"><a href=\\\"#type-definitions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Type Definitions</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Tuple</th>\\n<th>Reason Tuple</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type tuple = int * int</code></td>\\n<td><code>type tuple = (int, int);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tup: tuple = (10, 30)</code></td>\\n<td><code>let tup: tuple = (10, 30);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Record</th>\\n<th>Reason Record</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type r = {x: int; y: int}</code></td>\\n<td><code>type r = {x: int, y: int};</code></td>\\n</tr>\\n<tr>\\n<td><code>let myRec: r = {x = 0; y = 10}</code></td>\\n<td><code>let myRec: r = {x: 0, y: 10};</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Function</th>\\n<th>Reason Function</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type func = int -> int</code></td>\\n<td><code>type func = int => int;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x: func = fun a -> a + 1</code></td>\\n<td><code>let x: func = fun a => a + 1;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"functions\\\"><a href=\\\"#functions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functions</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let x a b = e</code></td>\\n<td><code>let x a b => e;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = fun a b -> e</code></td>\\n<td><code>let x = fun a b => e;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = fun a -> fun b -> e</code></td>\\n<td><code>let x = fun a => fun b => e;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"single-argument-match-functions\\\"><a href=\\\"#single-argument-match-functions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Single argument match functions</h4>\\n<p>OCaml has a function definition (<code>function |</code>) which is considered to be\\nequivalent of <code>function a -> match a with ...</code>. Reason has the same, but\\nthe syntax makes it clear how it is actually an extension of a single argument\\nfunction. The single case match is a natural extension of the simple lambda,\\nand the multicase lambda is a natural extension of the single case lambda.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Form</p></th><th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      lambda\\n    </td>\\n    <td>\\n      <pre>\\nfun pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      one match case\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      many cases\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e\\n         | pat2 -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e\\n    | pat2 => e</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"annotating-arguments\\\"><a href=\\\"#annotating-arguments\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Annotating Arguments</h4>\\n<p>In both Reason and OCaml, arguments are annotated with types by (as with\\neverything else), wrapping them in parenthesis after appending\\n<code>:typeAnnotation</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<p>Both Reason and OCaml allow annotating the return type, when using the\\n\\\"super sugared let binding\\\" form.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-comment\\\">(* OCaml *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> * <span class=\\\"hljs-built_in\\\">int</span> = (a, b)\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">1</span>]\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> -&gt; <span class=\\\"hljs-built_in\\\">int</span> = <span class=\\\"hljs-keyword\\\">fun</span> x -&gt; x + a + b</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">/* Reason */</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class=\\\"hljs-number\\\">1</span>];\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> x<span class=\\\"hljs-params\\\"> </span></span></span>=&gt; x + a + b;</code></pre>\\n      </div>\\n<p>Because we're using <code>=></code> for all functions everywhere in Reason, there's\\none case where we need to add extra parens around a return type that is\\nitself a function type.</p>\\n<h4 id=\\\"type-parameters\\\"><a href=\\\"#type-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Type Parameters</h4>\\n<h5 id=\\\"ocaml\\\"><a href=\\\"#ocaml\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>OCaml</h5>\\n<p>OCaml's type applications (think \\\"generics\\\"), are applied in reverse order.</p>\\n<p>With OCaml, there are some unintuitive consequences of this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> x: <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">2</span>]\\n\\n<span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Parsed as: *)</span>\\n<span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = (<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span>) <span class=\\\"hljs-built_in\\\">list</span></code></pre>\\n      </div>\\n<p>Things get even more strange when type constructors accept multiple parameters.\\nMultiple arguments require parenthesis and commas to separate type parameters,\\nbut those parentheses don't represent tuples. The parentheses/comma form must\\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-keyword\\\">type</span> (<span class=\\\"hljs-symbol\\\">'a</span>, <span class=\\\"hljs-symbol\\\">'b</span>) tuple = <span class=\\\"hljs-symbol\\\">'a</span> * <span class=\\\"hljs-symbol\\\">'b</span>\\n\\n<span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = (<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Which is parsed as: *)</span>\\n<span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = ((<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple) <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Which allows a list of (tuples of (string and int)) *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class=\\\"hljs-string\\\">\\\"asdf\\\"</span>, <span class=\\\"hljs-number\\\">3</span>)]</code></pre>\\n      </div>\\n<h5 id=\\\"reason\\\"><a href=\\\"#reason\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Reason</h5>\\n<p>In summary, Reason unifies almost all of the syntax into simple \\\"function\\napplication\\\" style meaning that type parameters follow the same space-separated\\nlist pattern seen everywhere else in the syntax. As with everything else,\\nparentheses may be used to enforce precedence. This results in fewer syntactic\\npatterns to learn.</p>\\n<p>For example, you can imagine <code>list</code> being a \\\"function\\\" for types that accepts a\\ntype and returns a new type.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x: int list = [2]\\ntype listOfListOfInts = int list list\\ntype ('a, 'b) tup = ('a * 'b)\\ntype pairs = (int, int) tup list\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x: list int = [2];\\ntype listOfListOfInts = list (list int);\\ntype tup 'a 'b = ('a, 'b);\\ntype pairs = list (tup int int);\\nlet tuples: pairs = [(2, 3)];</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"tuples-as-type-parameters\\\"><a href=\\\"#tuples-as-type-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Tuples as Type Parameters</h3>\\n<p>Because OCaml uses parens and commas to represent multiple arguments to type\\nconstructors, it's confusing when one of the arguments to a type constructor is\\nitself a tuple. In OCaml, it's difficult to remember the difference between a\\ntype constructor accepting multiple arguments and a type constructor accepting\\na single argument which happens to be a tuple.</p>\\n<p>The following examples shows the difference between passing <em>two</em> type\\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type intPair = (int, int) pair</code></td>\\n<td><code>type intPair = pair int int;</code></td>\\n</tr>\\n<tr>\\n<td><code>type pairList = (int * int) list</code></td>\\n<td><code>type pairList = list (int, int);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<ul>\\n<li>In Reason, syntax that represent tuple or tuple types, always looks like\\ntuples.</li>\\n<li>In Reason, syntax that represent records or record types, always look like\\nrecords.</li>\\n<li>Just about everything else uses the syntactic pattern of function application\\n(space separated arguments).</li>\\n</ul>\\n<h3 id=\\\"variants\\\"><a href=\\\"#variants\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Variants</h3>\\n<h6 id=\\\"ocaml-1\\\"><a href=\\\"#ocaml-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>OCaml</h6>\\n<ul>\\n<li>OCaml already expects constructor argument types to be specified in tuple\\nform, so it's confusing when a single constructor expects a single argument\\nthat <em>happens</em> to be a tuple type.</li>\\n<li>What's even more confusing is that the constructors don't <em>actually</em> accept\\ntuples, yet the syntax appear to resemble tuples.</li>\\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\\noverlaps the syntax for constructing a variant with a single argument that\\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\\ntuple when you are not actually supplying a tuple.</li>\\n</ul>\\n<h6 id=\\\"reason-1\\\"><a href=\\\"#reason-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Reason</h6>\\n<ul>\\n<li>Variant constructor types are expected to be listed as space separated lists,\\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\\n<li>Constructing instances of the variant (as you would have guessed) follows\\nfunction application style (space separated lists).</li>\\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\\n<em>is</em> a tuple.</li>\\n</ul>\\n<table>\\n  <thead>\\n    <tr>\\n      <th scope=\\\"col\\\">\\n        <p>OCaml</p>\\n      </th>\\n      <th scope=\\\"col\\\">\\n        <p>Reason</p>\\n      </th>\\n    </tr>\\n  </thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype myVariant =\\n  | HasNothing\\n  | HasSingleInt of int\\n  | HasSingleTuple of (int * int)\\n  | HasMultipleInts of int * int\\n  | HasMultipleTuples of (int * int) * (int * int)\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype myVariant =\\n  | HasNothing\\n  | HasSingleInt int\\n  | HasSingleTuple (int, int)\\n  | HasMultipleInts int int\\n  | HasMultipleTuples (int, int) (int, int);\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet a = HasSingleInt 10\\nlet a = HasSingleTuple (10, 10)\\nlet a = HasMultipleInts (10, 10)\\nlet a = HasMultipleTuples ((10, 10), (10, 10))\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet a = HasSingleInt 10;\\nlet a = HasSingleTuple (10, 10);\\nlet a = HasMultipleInts 10 10;\\nlet a = HasMultipleTuples (10, 10) (10, 10);\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | HasNothing -> 0\\n  | HasSingleInt x -> 0\\n  | HasSingleTuple (x, y) -> 0\\n  | HasMultipleInts (x, y) -> 0\\n  | HasMultipleTuples ((x, y), (q, r)) -> 0\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n| HasNothing => 0\\n| HasSingleInt x => 0\\n| HasSingleTuple (x, y) => 0\\n| HasMultipleInts x y => 0\\n| HasMultipleTuples (x, y) (q, r) => 0\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"pattern-matching\\\"><a href=\\\"#pattern-matching\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Pattern Matching</h3>\\n<p>Can you spot the error in the OCaml example? This is one of the most common mistakes among OCaml programmers. The second <code>match</code> <em>must</em> be wrapped in parentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer <code>match</code>. Reason's required <code>{}</code> blocks around match cases prevent this issue.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml (BROKEN)</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | A (x, y) -> match y with\\n    | None -> 0\\n    | Some i -> 10\\n  | B (x, y) -> 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n  | A (x, y) => switch y {\\n    | None => 0\\n    | Some i => 10\\n  }\\n  | B x y => 0\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"modules-and-signatures\\\"><a href=\\\"#modules-and-signatures\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Modules and Signatures</h3>\\n<h4 id=\\\"definition\\\"><a href=\\\"#definition\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Definition</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type MySig = sig\\n  type t = int\\n  val x: int\\nend\\nmodule MyModule: MySig = struct\\n  type t = int\\n  let x = 10\\nend\\nmodule MyModule = struct\\n  module NestedModule = struct\\n     let msg = \\\"hello\\\";\\n  end\\nend\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type MySig = {\\n  type t = int;\\n  let x: int;\\n};\\nmodule MyModule: MySig = {\\n  type t = int;\\n  let x = 10;\\n};\\nmodule MyModule = {\\n  module NestedModule = {\\n     let msg = \\\"hello\\\";\\n  };\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"functors-types\\\"><a href=\\\"#functors-types\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functors Types</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type FType =\\n  functor (A: ASig) ->\\n  functor (B: BSig) -> Result\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type FType =\\n  (A: ASig) =>\\n  (B: BSig) => Result;\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"functors\\\"><a href=\\\"#functors\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functors</h3>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor (A: ASig) ->\\n  functor (B: BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A: ASig) =>\\n  fun (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F = functor (A: ASig) (B: BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F = fun (A: ASig) (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F (A: ASig) (B: BSig) = struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F (A: ASig) (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule Res = F(A)(B)</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule Res = F A B;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p><strong>Note: There is currently a known inconsistency where functors do not\\nconform to function application syntax when in type annotation position - see\\n<a href=\\\"https://github.com/facebook/reason\\\">the Reason repo's</a> <code>formatTest/modules.re</code>.</strong></p>\\n<h3 id=\\\"various-improvements\\\"><a href=\\\"#various-improvements\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Various Improvements</h3>\\n<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\\nReason always uses <code>{}</code> to enclose sequences or let bindings, and Reason\\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\\n<h4 id=\\\"lambdas-as-record-fields-no-longer-need-extra-parens\\\"><a href=\\\"#lambdas-as-record-fields-no-longer-need-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas as record fields no longer need extra parens</h4>\\n<p>This is a welcomed improvement because the OCaml type errors the user would\\nsee were very confusing when it would believe the function's return value\\nwas a tuple with infix <code>,</code> comma.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n}</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"lambdas-as-match-results-no-longer-need-extra-parens\\\"><a href=\\\"#lambdas-as-match-results-no-longer-need-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas as match results no longer need extra parens</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = match prnt with\\n  | None -> fun a -> blah\\n  (* Extra () required ! *)\\n  | Some \\\"_\\\" -> (fun a -> ())\\n  | Some \\\"ml\\\" -> blah\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = switch prnt {\\n| None => fun a => blah\\n| Some \\\"_\\\" => fun a => ()\\n| Some \\\"ml\\\" => blah\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens\\\"><a href=\\\"#lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas and type annotations in tuples no longer require extra parens</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let tuple = ((fun x -> x), 20)</code></td>\\n<td><code>let tuple = (fun x => x, 20);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tuple = ((\\\"hi\\\": string), (20: int))</code></td>\\n<td><code>let tuple = (\\\"hi\\\": string, 20: int);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"various-differences\\\"><a href=\\\"#various-differences\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Various Differences</h3>\\n<h4 id=\\\"as-precedence\\\"><a href=\\\"#as-precedence\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a><code>as</code> precedence</h4>\\n<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\\nfor entire rows in pattern matching.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ppp = match MyThing 20 with\\n  | (MyThing x as ppp)\\n  | (YourThing x as ppp) -> ppp;\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ppp = switch (MyThing 20) {\\n| MyThing x as ppp\\n| YourThing x as ppp => ppp;\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet | (MyThing _ as ppp)\\n    | (YourThing _ as ppp) = ppp;</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet | MyThing _ as ppp\\n    | YourThing _ as ppp = ppp;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"mutable-record-field-updates\\\"><a href=\\\"#mutable-record-field-updates\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Mutable Record Field Updates</h4>\\n<p>Because equalities and their negations have been made more consistent in Reason,\\nthe <code>=</code> operator is available for mutable field update.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>myRec.field &#x3C;- \\\"next\\\"</code></td>\\n<td><code>myRec.field = \\\"next\\\"</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"prefix-operators\\\"><a href=\\\"#prefix-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Prefix operators</h4>\\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\\nThis is more consistent with what other languages do, and is more practical\\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let x = !(foo.bar)</code></td>\\n<td><code>let x = !foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(foo#bar)</code></td>\\n<td><code>let x = !foo#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!foo.bar)</code></td>\\n<td><code>let x = !(!foo).bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!foo#bar)</code></td>\\n<td><code>let x = !(!foo)#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!(foo.bar))</code></td>\\n<td><code>let x = !(!foo.bar);</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!(foo#bar))</code></td>\\n<td><code>let x = !(!foo#bar);</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !!(foo.bar)</code></td>\\n<td><code>let x = !!foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !!(foo#bar)</code></td>\\n<td><code>let x = !!foo#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !~(foo.bar)</code></td>\\n<td><code>let x = !~foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !~(foo#bar)</code></td>\\n<td><code>let x = !~foo#bar;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"comment-escaping\\\"><a href=\\\"#comment-escaping\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Comment Escaping</h4>\\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\\noperators must be written differently.  The rules for prefix/infix operators\\nare the same as in OCaml syntax, but with the following exceptions:</p>\\n<p>Specifically, if any character except the first in an prefix/infix operator is\\na star or forward slash, that must be first escaped with a backslash. These will\\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\\nescape backslashes are added back in automatically.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let (/*) a b = a + b</code></td>\\n<td><code>let (/\\\\*) a b => a + b;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = 12 /-* 23 /-* 12</code></td>\\n<td><code>let x = 12 /-\\\\* 23 /-\\\\* 12;</code></td>\\n</tr>\\n<tr>\\n<td><code>let y = (/*) a b</code></td>\\n<td><code>let y = (/\\\\*) a b;</code></td>\\n</tr>\\n<tr>\\n<td><code>let (!=*) q r => q + r</code></td>\\n<td><code>let (!=\\\\*) q r => q + r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let res = q (!=*) r</code></td>\\n<td><code>let res = q (!=\\\\*) r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let (!=/*) q r = q + r</code></td>\\n<td><code>let (!=\\\\/\\\\*) q r => q + r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let res = q (!=/*) r</code></td>\\n<td><code>let res = q (!=\\\\/\\\\*) r;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"operator-renaming-1\\\"><a href=\\\"#operator-renaming-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Operator Renaming</h4>\\n<p>If Reason uses <code>==</code> to represent OCaml's <code>=</code>, and\\nuses <code>===</code> to represent OCaml's <code>==</code>, then how would Reason represent OCaml's\\n<code>===</code> symbol (if it were defined)? Reason provides a way! \\\"Escape\\\" the triple\\nequals symbol!</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Identifier</th>\\n<th>Meaning</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>\\\"===\\\"</code></td>\\n<td>Custom value</td>\\n<td><code>x === y</code></td>\\n<td><code>x \\\\=== y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"repl\\\"><a href=\\\"#repl\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>REPL</h4>\\n<p>In Reason's repl <a href=\\\"/guide/editor-tools/extra-goodies#repl\\\"><code>rtop</code></a> (a customized <a href=\\\"https://github.com/diml/utop\\\"><code>utop</code></a>), each input is submitted via a single <code>;</code> semicolon. OCaml's repl requires two semicolons <code>;;</code>.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>;;</code></td>\\n<td><code>;</code></td>\\n</tr>\\n</tbody>\\n</table>\",\n\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\"title\": \"Comparison to OCaml\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"section\": \"guide\",\n\t\t\t\"sectionTitle\": \"Guide\",\n\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\"relatedFiles\": \"/^guide\\\\/.*\\\\.md$/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---guide-ocaml-a337256bed76ada3755e.js","module.exports = {\n\t\"data\": {\n\t\t\"allFile\": {\n\t\t\t\"edges\": [\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"The Reason Guide\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/examples.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Examples\",\n\t\t\t\t\t\t\t\t\"order\": 60\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Comparison to OCaml\",\n\t\t\t\t\t\t\t\t\"order\": 50\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/what-and-why.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"What & Why\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/converting.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Converting from JS\",\n\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"JavaScript\",\n\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/libraries.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Libraries\",\n\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/interop.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Interop\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/exception.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Exception\",\n\t\t\t\t\t\t\t\t\"order\": 175\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/syntax-cheatsheet.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Syntax Cheatsheet\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/quickstart.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/boolean.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Boolean\",\n\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/destructuring.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Destructuring\",\n\t\t\t\t\t\t\t\t\"order\": 130\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/external.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"External\",\n\t\t\t\t\t\t\t\t\"order\": 170\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/function.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Function\",\n\t\t\t\t\t\t\t\t\"order\": 100\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/if-else.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"If-Else\",\n\t\t\t\t\t\t\t\t\"order\": 110\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Language basics\",\n\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/imperative-loops.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Imperative Loops\",\n\t\t\t\t\t\t\t\t\"order\": 150\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/jsx.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"JSX\",\n\t\t\t\t\t\t\t\t\"order\": 160\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/integer-and-float.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Integer & Float\",\n\t\t\t\t\t\t\t\t\"order\": 40\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/more-on-type.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"More on Type\",\n\t\t\t\t\t\t\t\t\"order\": 120\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/let-binding.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Let Binding\",\n\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/list-and-array.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"List & Array\",\n\t\t\t\t\t\t\t\t\"order\": 80\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/module.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Module\",\n\t\t\t\t\t\t\t\t\"order\": 180\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/mutation.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Mutation\",\n\t\t\t\t\t\t\t\t\"order\": 140\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/overview.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Overview\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/object.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Object\",\n\t\t\t\t\t\t\t\t\"order\": 175\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/pattern-matching.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Pattern Matching!\",\n\t\t\t\t\t\t\t\t\"order\": 135\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/type.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Type!\",\n\t\t\t\t\t\t\t\t\"order\": 15\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/record.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Record\",\n\t\t\t\t\t\t\t\t\"order\": 60\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/tuple.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Tuple\",\n\t\t\t\t\t\t\t\t\"order\": 50\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/string-and-char.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"String & Char\",\n\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/convert-from-ocaml.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Converting from OCaml\",\n\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/quickstart.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Native\",\n\t\t\t\t\t\t\t\t\"order\": 40\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/variant.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Variant!\",\n\t\t\t\t\t\t\t\t\"order\": 70\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/extra-goodies.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Extra Goodies\",\n\t\t\t\t\t\t\t\t\"order\": 30\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/editors-plugins.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Editors Plugins\",\n\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/global-installation.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Global Installation\",\n\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/editor-tools/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Editor Setup\",\n\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t\"file\": {\n\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\"html\": \"<p>If you come from OCaml or are a newcomer reading a tutorial written on OCaml, this guide's for you! But don't forget that <a href=\\\"https://github.com/reasonml/reason-tools\\\">reason-tools</a> can convert between OCaml and Reason syntax on the fly.</p>\\n<h3 id=\\\"comments\\\"><a href=\\\"#comments\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Comments</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>(* OCaml (*nest*) *)</code></td>\\n<td><code>/* Reason /*nest*/ */</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"operator-renaming\\\"><a href=\\\"#operator-renaming\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Operator Renaming</h3>\\n<p>Reason has all of OCaml's infix operators, but a couple of operators are expressed differently. In Reason, structural equality is written as <code>==</code>, and reference (physical) equality is written as <code>===</code>. In Reason, to achieve the corresponding inequality, simply swap the first character with a <code>!</code> character. (<code>!=</code> for structural inequality, and <code>!==</code> for reference inequality).</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Equality</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Structural</td>\\n<td><code>x = y</code></td>\\n<td><code>x == y</code></td>\\n</tr>\\n<tr>\\n<td>Reference</td>\\n<td><code>x == y</code></td>\\n<td><code>x === y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>Inequality</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Structural</td>\\n<td><code>x &#x3C;> y</code></td>\\n<td><code>x != y</code></td>\\n</tr>\\n<tr>\\n<td>Reference</td>\\n<td><code>x != y</code></td>\\n<td><code>x !== y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"local-scope\\\"><a href=\\\"#local-scope\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Local Scope</h3>\\n<p>Reason's lexical scoping is exactly the same as OCaml's, but let bindings syntactically resemble \\\"block scope\\\" which is more familiar to many developers. In Reason, they are created with <code>{}</code> braces, which may contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>. All blocks evaluate to the last line and the semicolon on the last line is optional. <code>{}</code> braces are only needed if you have more than one item to chain together via <code>;</code>.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet _ =\\n  let msg = \\\"Hello\\\" in\\n  print_string msg;\\n  let msg2 = \\\"Goodbye\\\" in\\n  print_string msg2</pre>\\n    </td>\\n    <td>\\n      <pre>\\n{\\n  let msg = \\\"Hello\\\";\\n  print_string msg;\\n  let msg2 = \\\"Goodbye\\\";\\n  print_string msg2\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p>Reason's <code>{}</code> syntax removes many commonly reported pain points in OCaml's syntax:</p>\\n<ul>\\n<li>Double semicolons are removed entirely.</li>\\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\\n<li>Infamous imperative parsing <a href=\\\"https://github.com/ocaml/ocaml/pull/278\\\">issues</a> are gone.</li>\\n<li>Module bodies and local scope are unified.</li>\\n</ul>\\n<h3 id=\\\"local-scope-vs-module-body\\\"><a href=\\\"#local-scope-vs-module-body\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Local Scope Vs. Module Body</h3>\\n<p>In Reason, everything that can go between the <code>{}</code> in <a href=\\\"#local-scope\\\">Local Scopes</a> and in module bodies. You can usually even cut/paste code between the two contexts. In OCaml, the syntaxes for the two contexts are very different. Local scope requires trailing <code>in</code>, but module bodies do not and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Module Body</p></th><th scope=\\\"col\\\"><p>Reason Module Body</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10\\nlet () = imperativeFunc ten ten\\nlet () = imperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ten = 10;\\nimperativeFunc ten ten;\\nimperativeFunc 0 0;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10;;\\nimperativeFunc ten ten;;\\nimperativeFunc 0 0;;</pre>\\n    </td>\\n    <td>Same as above</td>\\n  </tr>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Local Scope</p></th><th scope=\\\"col\\\"><p>Reason Local Scope</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in\\nlet _ = imperativeFunc ten ten in\\nimperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in begin\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\nend</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in (\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\n)</pre>\\n    </td>\\n    <td>\\n       same as above\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"tuple-and-record\\\"><a href=\\\"#tuple-and-record\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Tuple and Record</h3>\\n<p>In Reason, tuples always require parentheses.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let tup = 4, 5</code></td>\\n<td><code>let tup = (4, 5);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tup = ((1: int), (2:int))</code></td>\\n<td><code>let tup = (1: int, 2:int);</code></td>\\n</tr>\\n<tr>\\n<td><code>fun ((a: int), (b: int)) -> a</code></td>\\n<td><code>fun (a: int, b: int) => a;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>In Reason, record values resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because Reason tuples always require wrapping parens, records may contain lambdas as values without needing extra parens.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myRec = {x = 0; y = 10}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myRec = {x: 0, y: 10};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n};</pre>\\n    </td>\\n</table>\\n<h3 id=\\\"lists\\\"><a href=\\\"#lists\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lists</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let list = [1; 2; 3]</code></td>\\n<td><code>let list = [1, 2, 3]</code></td>\\n</tr>\\n<tr>\\n<td><code>let list = hd :: tl</code></td>\\n<td><code>let list = [hd, ...tl];</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"type-definitions\\\"><a href=\\\"#type-definitions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Type Definitions</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Tuple</th>\\n<th>Reason Tuple</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type tuple = int * int</code></td>\\n<td><code>type tuple = (int, int);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tup: tuple = (10, 30)</code></td>\\n<td><code>let tup: tuple = (10, 30);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Record</th>\\n<th>Reason Record</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type r = {x: int; y: int}</code></td>\\n<td><code>type r = {x: int, y: int};</code></td>\\n</tr>\\n<tr>\\n<td><code>let myRec: r = {x = 0; y = 10}</code></td>\\n<td><code>let myRec: r = {x: 0, y: 10};</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml Function</th>\\n<th>Reason Function</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type func = int -> int</code></td>\\n<td><code>type func = int => int;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x: func = fun a -> a + 1</code></td>\\n<td><code>let x: func = fun a => a + 1;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"functions\\\"><a href=\\\"#functions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functions</h3>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let x a b = e</code></td>\\n<td><code>let x a b => e;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = fun a b -> e</code></td>\\n<td><code>let x = fun a b => e;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = fun a -> fun b -> e</code></td>\\n<td><code>let x = fun a => fun b => e;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"single-argument-match-functions\\\"><a href=\\\"#single-argument-match-functions\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Single argument match functions</h4>\\n<p>OCaml has a function definition (<code>function |</code>) which is considered to be\\nequivalent of <code>function a -> match a with ...</code>. Reason has the same, but\\nthe syntax makes it clear how it is actually an extension of a single argument\\nfunction. The single case match is a natural extension of the simple lambda,\\nand the multicase lambda is a natural extension of the single case lambda.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Form</p></th><th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      lambda\\n    </td>\\n    <td>\\n      <pre>\\nfun pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      one match case\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      many cases\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e\\n         | pat2 -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e\\n    | pat2 => e</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"annotating-arguments\\\"><a href=\\\"#annotating-arguments\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Annotating Arguments</h4>\\n<p>In both Reason and OCaml, arguments are annotated with types by (as with\\neverything else), wrapping them in parenthesis after appending\\n<code>:typeAnnotation</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<p>Both Reason and OCaml allow annotating the return type, when using the\\n\\\"super sugared let binding\\\" form.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-comment\\\">(* OCaml *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> * <span class=\\\"hljs-built_in\\\">int</span> = (a, b)\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">1</span>]\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> -&gt; <span class=\\\"hljs-built_in\\\">int</span> = <span class=\\\"hljs-keyword\\\">fun</span> x -&gt; x + a + b</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">/* Reason */</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class=\\\"hljs-number\\\">1</span>];\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> x<span class=\\\"hljs-params\\\"> </span></span></span>=&gt; x + a + b;</code></pre>\\n      </div>\\n<p>Because we're using <code>=></code> for all functions everywhere in Reason, there's\\none case where we need to add extra parens around a return type that is\\nitself a function type.</p>\\n<h4 id=\\\"type-parameters\\\"><a href=\\\"#type-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Type Parameters</h4>\\n<h5 id=\\\"ocaml\\\"><a href=\\\"#ocaml\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>OCaml</h5>\\n<p>OCaml's type applications (think \\\"generics\\\"), are applied in reverse order.</p>\\n<p>With OCaml, there are some unintuitive consequences of this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-keyword\\\">let</span> x: <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">2</span>]\\n\\n<span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Parsed as: *)</span>\\n<span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = (<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span>) <span class=\\\"hljs-built_in\\\">list</span></code></pre>\\n      </div>\\n<p>Things get even more strange when type constructors accept multiple parameters.\\nMultiple arguments require parenthesis and commas to separate type parameters,\\nbut those parentheses don't represent tuples. The parentheses/comma form must\\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-keyword\\\">type</span> (<span class=\\\"hljs-symbol\\\">'a</span>, <span class=\\\"hljs-symbol\\\">'b</span>) tuple = <span class=\\\"hljs-symbol\\\">'a</span> * <span class=\\\"hljs-symbol\\\">'b</span>\\n\\n<span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = (<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Which is parsed as: *)</span>\\n<span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = ((<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple) <span class=\\\"hljs-built_in\\\">list</span>\\n\\n<span class=\\\"hljs-comment\\\">(* Which allows a list of (tuples of (string and int)) *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class=\\\"hljs-string\\\">\\\"asdf\\\"</span>, <span class=\\\"hljs-number\\\">3</span>)]</code></pre>\\n      </div>\\n<h5 id=\\\"reason\\\"><a href=\\\"#reason\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Reason</h5>\\n<p>In summary, Reason unifies almost all of the syntax into simple \\\"function\\napplication\\\" style meaning that type parameters follow the same space-separated\\nlist pattern seen everywhere else in the syntax. As with everything else,\\nparentheses may be used to enforce precedence. This results in fewer syntactic\\npatterns to learn.</p>\\n<p>For example, you can imagine <code>list</code> being a \\\"function\\\" for types that accepts a\\ntype and returns a new type.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x: int list = [2]\\ntype listOfListOfInts = int list list\\ntype ('a, 'b) tup = ('a * 'b)\\ntype pairs = (int, int) tup list\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x: list int = [2];\\ntype listOfListOfInts = list (list int);\\ntype tup 'a 'b = ('a, 'b);\\ntype pairs = list (tup int int);\\nlet tuples: pairs = [(2, 3)];</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"tuples-as-type-parameters\\\"><a href=\\\"#tuples-as-type-parameters\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Tuples as Type Parameters</h3>\\n<p>Because OCaml uses parens and commas to represent multiple arguments to type\\nconstructors, it's confusing when one of the arguments to a type constructor is\\nitself a tuple. In OCaml, it's difficult to remember the difference between a\\ntype constructor accepting multiple arguments and a type constructor accepting\\na single argument which happens to be a tuple.</p>\\n<p>The following examples shows the difference between passing <em>two</em> type\\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>type intPair = (int, int) pair</code></td>\\n<td><code>type intPair = pair int int;</code></td>\\n</tr>\\n<tr>\\n<td><code>type pairList = (int * int) list</code></td>\\n<td><code>type pairList = list (int, int);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<ul>\\n<li>In Reason, syntax that represent tuple or tuple types, always looks like\\ntuples.</li>\\n<li>In Reason, syntax that represent records or record types, always look like\\nrecords.</li>\\n<li>Just about everything else uses the syntactic pattern of function application\\n(space separated arguments).</li>\\n</ul>\\n<h3 id=\\\"variants\\\"><a href=\\\"#variants\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Variants</h3>\\n<h6 id=\\\"ocaml-1\\\"><a href=\\\"#ocaml-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>OCaml</h6>\\n<ul>\\n<li>OCaml already expects constructor argument types to be specified in tuple\\nform, so it's confusing when a single constructor expects a single argument\\nthat <em>happens</em> to be a tuple type.</li>\\n<li>What's even more confusing is that the constructors don't <em>actually</em> accept\\ntuples, yet the syntax appear to resemble tuples.</li>\\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\\noverlaps the syntax for constructing a variant with a single argument that\\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\\ntuple when you are not actually supplying a tuple.</li>\\n</ul>\\n<h6 id=\\\"reason-1\\\"><a href=\\\"#reason-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Reason</h6>\\n<ul>\\n<li>Variant constructor types are expected to be listed as space separated lists,\\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\\n<li>Constructing instances of the variant (as you would have guessed) follows\\nfunction application style (space separated lists).</li>\\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\\n<em>is</em> a tuple.</li>\\n</ul>\\n<table>\\n  <thead>\\n    <tr>\\n      <th scope=\\\"col\\\">\\n        <p>OCaml</p>\\n      </th>\\n      <th scope=\\\"col\\\">\\n        <p>Reason</p>\\n      </th>\\n    </tr>\\n  </thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype myVariant =\\n  | HasNothing\\n  | HasSingleInt of int\\n  | HasSingleTuple of (int * int)\\n  | HasMultipleInts of int * int\\n  | HasMultipleTuples of (int * int) * (int * int)\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype myVariant =\\n  | HasNothing\\n  | HasSingleInt int\\n  | HasSingleTuple (int, int)\\n  | HasMultipleInts int int\\n  | HasMultipleTuples (int, int) (int, int);\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet a = HasSingleInt 10\\nlet a = HasSingleTuple (10, 10)\\nlet a = HasMultipleInts (10, 10)\\nlet a = HasMultipleTuples ((10, 10), (10, 10))\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet a = HasSingleInt 10;\\nlet a = HasSingleTuple (10, 10);\\nlet a = HasMultipleInts 10 10;\\nlet a = HasMultipleTuples (10, 10) (10, 10);\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | HasNothing -> 0\\n  | HasSingleInt x -> 0\\n  | HasSingleTuple (x, y) -> 0\\n  | HasMultipleInts (x, y) -> 0\\n  | HasMultipleTuples ((x, y), (q, r)) -> 0\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n| HasNothing => 0\\n| HasSingleInt x => 0\\n| HasSingleTuple (x, y) => 0\\n| HasMultipleInts x y => 0\\n| HasMultipleTuples (x, y) (q, r) => 0\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"pattern-matching\\\"><a href=\\\"#pattern-matching\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Pattern Matching</h3>\\n<p>Can you spot the error in the OCaml example? This is one of the most common mistakes among OCaml programmers. The second <code>match</code> <em>must</em> be wrapped in parentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer <code>match</code>. Reason's required <code>{}</code> blocks around match cases prevent this issue.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml (BROKEN)</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | A (x, y) -> match y with\\n    | None -> 0\\n    | Some i -> 10\\n  | B (x, y) -> 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n  | A (x, y) => switch y {\\n    | None => 0\\n    | Some i => 10\\n  }\\n  | B x y => 0\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"modules-and-signatures\\\"><a href=\\\"#modules-and-signatures\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Modules and Signatures</h3>\\n<h4 id=\\\"definition\\\"><a href=\\\"#definition\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Definition</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type MySig = sig\\n  type t = int\\n  val x: int\\nend\\nmodule MyModule: MySig = struct\\n  type t = int\\n  let x = 10\\nend\\nmodule MyModule = struct\\n  module NestedModule = struct\\n     let msg = \\\"hello\\\";\\n  end\\nend\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type MySig = {\\n  type t = int;\\n  let x: int;\\n};\\nmodule MyModule: MySig = {\\n  type t = int;\\n  let x = 10;\\n};\\nmodule MyModule = {\\n  module NestedModule = {\\n     let msg = \\\"hello\\\";\\n  };\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"functors-types\\\"><a href=\\\"#functors-types\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functors Types</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type FType =\\n  functor (A: ASig) ->\\n  functor (B: BSig) -> Result\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type FType =\\n  (A: ASig) =>\\n  (B: BSig) => Result;\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3 id=\\\"functors\\\"><a href=\\\"#functors\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Functors</h3>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor (A: ASig) ->\\n  functor (B: BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A: ASig) =>\\n  fun (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F = functor (A: ASig) (B: BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F = fun (A: ASig) (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F (A: ASig) (B: BSig) = struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F (A: ASig) (B: BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule Res = F(A)(B)</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule Res = F A B;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p><strong>Note: There is currently a known inconsistency where functors do not\\nconform to function application syntax when in type annotation position - see\\n<a href=\\\"https://github.com/facebook/reason\\\">the Reason repo's</a> <code>formatTest/modules.re</code>.</strong></p>\\n<h3 id=\\\"various-improvements\\\"><a href=\\\"#various-improvements\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Various Improvements</h3>\\n<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\\nReason always uses <code>{}</code> to enclose sequences or let bindings, and Reason\\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\\n<h4 id=\\\"lambdas-as-record-fields-no-longer-need-extra-parens\\\"><a href=\\\"#lambdas-as-record-fields-no-longer-need-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas as record fields no longer need extra parens</h4>\\n<p>This is a welcomed improvement because the OCaml type errors the user would\\nsee were very confusing when it would believe the function's return value\\nwas a tuple with infix <code>,</code> comma.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n}</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"lambdas-as-match-results-no-longer-need-extra-parens\\\"><a href=\\\"#lambdas-as-match-results-no-longer-need-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas as match results no longer need extra parens</h4>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = match prnt with\\n  | None -> fun a -> blah\\n  (* Extra () required ! *)\\n  | Some \\\"_\\\" -> (fun a -> ())\\n  | Some \\\"ml\\\" -> blah\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = switch prnt {\\n| None => fun a => blah\\n| Some \\\"_\\\" => fun a => ()\\n| Some \\\"ml\\\" => blah\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens\\\"><a href=\\\"#lambdas-and-type-annotations-in-tuples-no-longer-require-extra-parens\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Lambdas and type annotations in tuples no longer require extra parens</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let tuple = ((fun x -> x), 20)</code></td>\\n<td><code>let tuple = (fun x => x, 20);</code></td>\\n</tr>\\n<tr>\\n<td><code>let tuple = ((\\\"hi\\\": string), (20: int))</code></td>\\n<td><code>let tuple = (\\\"hi\\\": string, 20: int);</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h3 id=\\\"various-differences\\\"><a href=\\\"#various-differences\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Various Differences</h3>\\n<h4 id=\\\"as-precedence\\\"><a href=\\\"#as-precedence\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a><code>as</code> precedence</h4>\\n<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\\nfor entire rows in pattern matching.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ppp = match MyThing 20 with\\n  | (MyThing x as ppp)\\n  | (YourThing x as ppp) -> ppp;\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ppp = switch (MyThing 20) {\\n| MyThing x as ppp\\n| YourThing x as ppp => ppp;\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet | (MyThing _ as ppp)\\n    | (YourThing _ as ppp) = ppp;</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet | MyThing _ as ppp\\n    | YourThing _ as ppp = ppp;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h4 id=\\\"mutable-record-field-updates\\\"><a href=\\\"#mutable-record-field-updates\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Mutable Record Field Updates</h4>\\n<p>Because equalities and their negations have been made more consistent in Reason,\\nthe <code>=</code> operator is available for mutable field update.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>myRec.field &#x3C;- \\\"next\\\"</code></td>\\n<td><code>myRec.field = \\\"next\\\"</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"prefix-operators\\\"><a href=\\\"#prefix-operators\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Prefix operators</h4>\\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\\nThis is more consistent with what other languages do, and is more practical\\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let x = !(foo.bar)</code></td>\\n<td><code>let x = !foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(foo#bar)</code></td>\\n<td><code>let x = !foo#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!foo.bar)</code></td>\\n<td><code>let x = !(!foo).bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!foo#bar)</code></td>\\n<td><code>let x = !(!foo)#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!(foo.bar))</code></td>\\n<td><code>let x = !(!foo.bar);</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !(!(foo#bar))</code></td>\\n<td><code>let x = !(!foo#bar);</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !!(foo.bar)</code></td>\\n<td><code>let x = !!foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !!(foo#bar)</code></td>\\n<td><code>let x = !!foo#bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !~(foo.bar)</code></td>\\n<td><code>let x = !~foo.bar;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = !~(foo#bar)</code></td>\\n<td><code>let x = !~foo#bar;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"comment-escaping\\\"><a href=\\\"#comment-escaping\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Comment Escaping</h4>\\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\\noperators must be written differently.  The rules for prefix/infix operators\\nare the same as in OCaml syntax, but with the following exceptions:</p>\\n<p>Specifically, if any character except the first in an prefix/infix operator is\\na star or forward slash, that must be first escaped with a backslash. These will\\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\\nescape backslashes are added back in automatically.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>let (/*) a b = a + b</code></td>\\n<td><code>let (/\\\\*) a b => a + b;</code></td>\\n</tr>\\n<tr>\\n<td><code>let x = 12 /-* 23 /-* 12</code></td>\\n<td><code>let x = 12 /-\\\\* 23 /-\\\\* 12;</code></td>\\n</tr>\\n<tr>\\n<td><code>let y = (/*) a b</code></td>\\n<td><code>let y = (/\\\\*) a b;</code></td>\\n</tr>\\n<tr>\\n<td><code>let (!=*) q r => q + r</code></td>\\n<td><code>let (!=\\\\*) q r => q + r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let res = q (!=*) r</code></td>\\n<td><code>let res = q (!=\\\\*) r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let (!=/*) q r = q + r</code></td>\\n<td><code>let (!=\\\\/\\\\*) q r => q + r;</code></td>\\n</tr>\\n<tr>\\n<td><code>let res = q (!=/*) r</code></td>\\n<td><code>let res = q (!=\\\\/\\\\*) r;</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"operator-renaming-1\\\"><a href=\\\"#operator-renaming-1\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>Operator Renaming</h4>\\n<p>If Reason uses <code>==</code> to represent OCaml's <code>=</code>, and\\nuses <code>===</code> to represent OCaml's <code>==</code>, then how would Reason represent OCaml's\\n<code>===</code> symbol (if it were defined)? Reason provides a way! \\\"Escape\\\" the triple\\nequals symbol!</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Identifier</th>\\n<th>Meaning</th>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>\\\"===\\\"</code></td>\\n<td>Custom value</td>\\n<td><code>x === y</code></td>\\n<td><code>x \\\\=== y</code></td>\\n</tr>\\n</tbody>\\n</table>\\n<h4 id=\\\"repl\\\"><a href=\\\"#repl\\\" aria-hidden=\\\"true\\\" class=\\\"anchor\\\"><svg aria-hidden=\\\"true\\\" height=\\\"16\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 16 16\\\" width=\\\"16\\\"><path fill-rule=\\\"evenodd\\\" d=\\\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\\\"></path></svg></a>REPL</h4>\\n<p>In Reason's repl <a href=\\\"/guide/editor-tools/extra-goodies#repl\\\"><code>rtop</code></a> (a customized <a href=\\\"https://github.com/diml/utop\\\"><code>utop</code></a>), each input is submitted via a single <code>;</code> semicolon. OCaml's repl requires two semicolons <code>;;</code>.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>;;</code></td>\\n<td><code>;</code></td>\\n</tr>\\n</tbody>\\n</table>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Comparison to OCaml\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"section\": \"guide\",\n\t\t\"sectionTitle\": \"Guide\",\n\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\"relatedFiles\": \"/^guide\\\\/.*\\\\.md$/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/guide-ocaml.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json\n// module chunks = 14"],"sourceRoot":""}