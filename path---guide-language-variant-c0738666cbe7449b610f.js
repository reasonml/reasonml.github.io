webpackJsonp([18],{"./node_modules/json-loader/index.js!./.cache/json/guide-language-variant.json":function(a,e){a.exports={data:{allFile:{edges:[{node:{relativePath:"guide/editor-setup.md",childMarkdownRemark:{frontmatter:{title:"Editor Setup",order:1}}}},{node:{relativePath:"guide/index.md",childMarkdownRemark:{frontmatter:{title:"The Reason Guide",order:0}}}},{node:{relativePath:"guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Examples",order:20}}}},{node:{relativePath:"guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:10}}}},{node:{relativePath:"guide/tools.md",childMarkdownRemark:{frontmatter:{title:"Tools",order:4}}}},{node:{relativePath:"guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:4}}}},{node:{relativePath:"guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Libraries",order:2}}}},{node:{relativePath:"guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Interop",order:1}}}},{node:{relativePath:"guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Converting from JS",order:5}}}},{node:{relativePath:"guide/language/array.md",childMarkdownRemark:{frontmatter:{title:"Array",order:90}}}},{node:{relativePath:"guide/language/boolean.md",childMarkdownRemark:{frontmatter:{title:"Boolean",order:30}}}},{node:{relativePath:"guide/language/conditionals.md",childMarkdownRemark:{frontmatter:{title:"Conditionals",order:110}}}},{node:{relativePath:"guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Destructuring & Pattern Matching",order:130}}}},{node:{relativePath:"guide/javascript/syntax-cheetsheet.md",childMarkdownRemark:{frontmatter:{title:"Syntax cheetsheet",order:1}}}},{node:{relativePath:"guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Language basics",order:1}}}},{node:{relativePath:"guide/language/integer-and-float.md",childMarkdownRemark:{frontmatter:{title:"Integer & Float",order:40}}}},{node:{relativePath:"guide/language/functions.md",childMarkdownRemark:{frontmatter:{title:"Functions",order:100}}}},{node:{relativePath:"guide/language/externals.md",childMarkdownRemark:{frontmatter:{title:"Externals",order:170}}}},{node:{relativePath:"guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Imperative Loops",order:150}}}},{node:{relativePath:"guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:160}}}},{node:{relativePath:"guide/language/list.md",childMarkdownRemark:{frontmatter:{title:"List",order:80}}}},{node:{relativePath:"guide/language/let-bindings.md",childMarkdownRemark:{frontmatter:{title:"Let Bindings",order:10}}}},{node:{relativePath:"guide/language/modules.md",childMarkdownRemark:{frontmatter:{title:"Modules",order:180}}}},{node:{relativePath:"guide/language/string-and-char.md",childMarkdownRemark:{frontmatter:{title:"String & Char",order:20}}}},{node:{relativePath:"guide/language/overview.md",childMarkdownRemark:{frontmatter:{title:"Overview",order:0}}}},{node:{relativePath:"guide/language/tuple.md",childMarkdownRemark:{frontmatter:{title:"Tuple",order:50}}}},{node:{relativePath:"guide/language/types.md",childMarkdownRemark:{frontmatter:{title:"Types!",order:120}}}},{node:{relativePath:"guide/language/variant.md",childMarkdownRemark:{frontmatter:{title:"Variant",order:70}}}},{node:{relativePath:"guide/language/record.md",childMarkdownRemark:{frontmatter:{title:"Record",order:60}}}},{node:{relativePath:"guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Mutation",order:140}}}},{node:{relativePath:"guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:5}}}},{node:{relativePath:"guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}}]},file:{relativePath:"guide/language/variant.md",childMarkdownRemark:{html:'<p>Behold, the crown jewel of Reason data structures!</p>\n<p>Most data structures are about "this <strong>and</strong> that". A variant allows us to express "this <strong>or</strong> that".</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> response =\n| <span class="hljs-type">Yes</span>\n| <span class="hljs-type">No</span>\n| <span class="hljs-type">PrettyMuch</span>;\n\n<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-type">Yes</span>;</code></pre>\n      </div>\n<p><code>Yes</code>, <code>No</code> and <code>PrettyMuch</code> aren\'t strings, nor references, nor some special data type. They\'re called "constructors" (or "tag"). The <code>|</code> bar separates each constructor.</p>\n<p><strong>Note</strong>: variant constructors need to be capitalized.</p>\n<p>A <code>switch</code> expression is like a large <code>if/elseif/elseif..</code> that allows you to check every possible case of a variant. To use it, enumerate every variant constructor, each followed by an <code>=></code> and the expression corresponding to that case.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">switch</span> (areYouCrushingIt) {\n| <span class="hljs-type">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>\n| <span class="hljs-type">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>\n| <span class="hljs-type">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>\n};\n<span class="hljs-comment">/* message is "Great!" */</span></code></pre>\n      </div>\n<p>The compiler will raise a type error if you\'ve forgotten to cover a case of your\nvariant, or if two cases are redundant!</p>\n<h5 id="constructor-arguments"><a href="#constructor-arguments" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Constructor Arguments</h5>\n<p>Constructors can carry extra data in a space-separated list.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">None</span>\n| <span class="hljs-type">Instagram</span> string\n| <span class="hljs-type">Facebook</span> string int;</code></pre>\n      </div>\n<p>Here, <code>Instagram</code> carries a <code>string</code> and <code>Facebook</code> carries a <code>string</code> and an <code>int</code>. Usage:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myAccount = <span class="hljs-type">Facebook</span> <span class="hljs-string">"Josh"</span> <span class="hljs-number">26</span>;\n<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-type">Instagram</span> <span class="hljs-string">"Jenny"</span>;</code></pre>\n      </div>\n<p><strong>Note</strong> how using a constructor is like calling a function! It\'s as if <code>Facebook</code> was a function that accepts two arguments. This isn\'t a coincidence; there\'s a reason why a constructor\'s data is called "argument".</p>\n<p><strong>Note</strong>: be careful not to confuse a constructor carrying 2 arguments with a constructor carrying a single tuple argument:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">Facebook</span> string int <span class="hljs-comment">/* 2 arguments */</span>\n<span class="hljs-keyword">type</span> account2 =\n| <span class="hljs-type">Instagram</span> (string, int) <span class="hljs-comment">/* 1 argument - happens to be a 2-tuple */</span></code></pre>\n      </div>\n<h5 id="using-switch-with-constructors-arguments"><a href="#using-switch-with-constructors-arguments" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using Switch with Constructors Arguments</h5>\n<p>The <code>switch</code> expression can also let you "open up" a variant and bind its arguments to names you can refer to.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">None</span>\n| <span class="hljs-type">Instagram</span> string\n| <span class="hljs-type">Facebook</span> string int;\n<span class="hljs-keyword">let</span> myAccount = <span class="hljs-type">Facebook</span> <span class="hljs-string">"Josh"</span> <span class="hljs-number">26</span>;\n...\n<span class="hljs-keyword">let</span> greeting = <span class="hljs-keyword">switch</span> (myAccount) {\n| <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi!"</span>\n| <span class="hljs-type">Facebook</span> name age =&gt;\n  <span class="hljs-string">"Hi "</span> ^ name ^ <span class="hljs-string">", you\'re "</span> ^ (string_of_int age) ^ <span class="hljs-string">"-year-old."</span>\n| <span class="hljs-type">Instagram</span> name =&gt; <span class="hljs-string">"Hello "</span> ^ name ^ <span class="hljs-string">"!"</span>\n}</code></pre>\n      </div>\n<p>This is called pattern-matching. It\'s a stronger version of destructuring, often found in other languages.</p>\n<h3 id="linked-list"><a href="#linked-list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>(Linked) List</h3>\n<p>Lists are homogeneous, immutable, and support fast <code>O(1)</code> append at the head of the list.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">let</span> anotherList = [<span class="hljs-number">0</span>, ...myList]; <span class="hljs-comment">/* myList didn\'t mutate */</span></code></pre>\n      </div>\n<p>Under the hood, a list is just a normal variant with a neat syntax. To illustrate this, here\'s how you would declare your own int list type, without the nice syntax:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> myListType = <span class="hljs-type">Empty</span> | <span class="hljs-type">NonEmpty</span> int myListType;\n<span class="hljs-keyword">let</span> myList = <span class="hljs-type">NonEmpty</span> <span class="hljs-number">1</span> (<span class="hljs-type">NonEmpty</span> <span class="hljs-number">2</span> (<span class="hljs-type">NonEmpty</span> <span class="hljs-number">3</span> <span class="hljs-type">Empty</span>));\n<span class="hljs-comment">/* basically [1, 2, 3] */</span></code></pre>\n      </div>\n<h3 id="array"><a href="#array" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array</h3>\n<p>Arrays are like lists, except they are mutable and support fast random access for performance-sensitive scenarios.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myArray = [|<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>|];\n<span class="hljs-keyword">let</span> world = myArray.(<span class="hljs-number">1</span>);\n<span class="hljs-type">Array</span>.<span class="hljs-keyword">set</span> myArray <span class="hljs-number">0</span> <span class="hljs-string">"hey"</span>;\n<span class="hljs-comment">/* now [|"hey", "world", "how are you"|] */</span></code></pre>\n      </div>',frontmatter:{title:"Variant"}}}},pathContext:{section:"guide",sectionTitle:"Guide",relativePath:"guide/language/variant.md",relatedFiles:"/^guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---guide-language-variant-c0738666cbe7449b610f.js.map