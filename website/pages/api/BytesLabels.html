<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Bytes.html">
<link rel="next" href="Callback.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Arg" rel="Chapter" href="Arg.html">
<link title="Array" rel="Chapter" href="Array.html">
<link title="ArrayLabels" rel="Chapter" href="ArrayLabels.html">
<link title="Buffer" rel="Chapter" href="Buffer.html">
<link title="Bytes" rel="Chapter" href="Bytes.html">
<link title="BytesLabels" rel="Chapter" href="BytesLabels.html">
<link title="Callback" rel="Chapter" href="Callback.html">
<link title="CamlinternalFormat" rel="Chapter" href="CamlinternalFormat.html">
<link title="CamlinternalFormatBasics" rel="Chapter" href="CamlinternalFormatBasics.html">
<link title="CamlinternalLazy" rel="Chapter" href="CamlinternalLazy.html">
<link title="CamlinternalMod" rel="Chapter" href="CamlinternalMod.html">
<link title="CamlinternalOO" rel="Chapter" href="CamlinternalOO.html">
<link title="Char" rel="Chapter" href="Char.html">
<link title="Complex" rel="Chapter" href="Complex.html">
<link title="Digest" rel="Chapter" href="Digest.html">
<link title="Filename" rel="Chapter" href="Filename.html">
<link title="Format" rel="Chapter" href="Format.html">
<link title="Gc" rel="Chapter" href="Gc.html">
<link title="Genlex" rel="Chapter" href="Genlex.html">
<link title="Hashtbl" rel="Chapter" href="Hashtbl.html">
<link title="Int32" rel="Chapter" href="Int32.html">
<link title="Int64" rel="Chapter" href="Int64.html">
<link title="Lazy" rel="Chapter" href="Lazy.html">
<link title="Lexing" rel="Chapter" href="Lexing.html">
<link title="List" rel="Chapter" href="List.html">
<link title="ListLabels" rel="Chapter" href="ListLabels.html">
<link title="Map" rel="Chapter" href="Map.html">
<link title="Marshal" rel="Chapter" href="Marshal.html">
<link title="MoreLabels" rel="Chapter" href="MoreLabels.html">
<link title="Nativeint" rel="Chapter" href="Nativeint.html">
<link title="Obj" rel="Chapter" href="Obj.html">
<link title="Oo" rel="Chapter" href="Oo.html">
<link title="Parsing" rel="Chapter" href="Parsing.html">
<link title="Pervasives" rel="Chapter" href="Pervasives.html">
<link title="Printexc" rel="Chapter" href="Printexc.html">
<link title="Printf" rel="Chapter" href="Printf.html">
<link title="Queue" rel="Chapter" href="Queue.html">
<link title="Random" rel="Chapter" href="Random.html">
<link title="Scanf" rel="Chapter" href="Scanf.html">
<link title="Set" rel="Chapter" href="Set.html">
<link title="Sort" rel="Chapter" href="Sort.html">
<link title="Stack" rel="Chapter" href="Stack.html">
<link title="StdLabels" rel="Chapter" href="StdLabels.html">
<link title="Stream" rel="Chapter" href="Stream.html">
<link title="String" rel="Chapter" href="String.html">
<link title="StringLabels" rel="Chapter" href="StringLabels.html">
<link title="Sys" rel="Chapter" href="Sys.html">
<link title="Weak" rel="Chapter" href="Weak.html">
<link title="Ast_helper" rel="Chapter" href="Ast_helper.html">
<link title="Ast_mapper" rel="Chapter" href="Ast_mapper.html">
<link title="Asttypes" rel="Chapter" href="Asttypes.html">
<link title="Docstrings" rel="Chapter" href="Docstrings.html">
<link title="Lexer" rel="Chapter" href="Lexer.html">
<link title="Location" rel="Chapter" href="Location.html">
<link title="Longident" rel="Chapter" href="Longident.html">
<link title="Parse" rel="Chapter" href="Parse.html">
<link title="Parser" rel="Chapter" href="Parser.html">
<link title="Parsetree" rel="Chapter" href="Parsetree.html">
<link title="Pprintast" rel="Chapter" href="Pprintast.html">
<link title="Printast" rel="Chapter" href="Printast.html">
<link title="Syntaxerr" rel="Chapter" href="Syntaxerr.html">
<link title="Unix" rel="Chapter" href="Unix.html">
<link title="Str" rel="Chapter" href="Str.html">
<link title="Bigarray" rel="Chapter" href="Bigarray.html">
<link title="Num" rel="Chapter" href="Num.html"><title>OCaml library : BytesLabels</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Bytes.html" title="Bytes">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Callback.html" title="Callback">Next</a>
</div>
<h1>Module <a href="type_BytesLabels.html">BytesLabels</a></h1>

<pre><span class="keyword">module</span> BytesLabels: <code class="code">sig</code> <a href="BytesLabels.html">..</a> <code class="code">end</code></pre><div class="info module top">
Byte sequence operations.<br>
<b>Since</b> 4.02.0<br>
</div>
<hr width="100%">

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">bytes -> int</code></pre><div class="info ">
Return the length (number of bytes) of the argument.<br>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type">bytes -> int -> char</code></pre><div class="info ">
<code class="code">get s n</code> returns the byte at index <code class="code">n</code> in argument <code class="code">s</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">n</code> not a valid index in <code class="code">s</code>.<br>
</div>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type">bytes -> int -> char -> unit</code></pre><div class="info ">
<code class="code">set s n c</code> modifies <code class="code">s</code> in place, replacing the byte at index <code class="code">n</code>
    with <code class="code">c</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">n</code> is not a valid index in <code class="code">s</code>.<br>
</div>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">int -> bytes</code></pre><div class="info ">
<code class="code">create n</code> returns a new byte sequence of length <code class="code">n</code>. The
    sequence is uninitialized and contains arbitrary bytes.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="Sys.html#VALmax_string_length"><code class="code">Sys.max_string_length</code></a>.<br>
</div>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">int -> char -> bytes</code></pre><div class="info ">
<code class="code">make n c</code> returns a new byte sequence of length <code class="code">n</code>, filled with
    the byte <code class="code">c</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="Sys.html#VALmax_string_length"><code class="code">Sys.max_string_length</code></a>.<br>
</div>

<pre><span id="VALinit"><span class="keyword">val</span> init</span> : <code class="type">int -> f:(int -> char) -> bytes</code></pre><div class="info ">
<code class="code">init n f</code> returns a fresh byte sequence of length <code class="code">n</code>,
    with character <code class="code">i</code> initialized to the result of <code class="code">f i</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="Sys.html#VALmax_string_length"><code class="code">Sys.max_string_length</code></a>.<br>
</div>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">bytes</code></pre><div class="info ">
A byte sequence of size 0.<br>
</div>

<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a new byte sequence that contains the same bytes as the
    argument.<br>
</div>

<pre><span id="VALof_string"><span class="keyword">val</span> of_string</span> : <code class="type">string -> bytes</code></pre><div class="info ">
Return a new byte sequence that contains the same bytes as the
    given string.<br>
</div>

<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type">bytes -> string</code></pre><div class="info ">
Return a new string that contains the same bytes as the given byte
    sequence.<br>
</div>

<pre><span id="VALsub"><span class="keyword">val</span> sub</span> : <code class="type">bytes -> pos:int -> len:int -> bytes</code></pre><div class="info ">
<code class="code">sub s start len</code> returns a new byte sequence of length <code class="code">len</code>,
    containing the subsequence of <code class="code">s</code> that starts at position <code class="code">start</code>
    and has length <code class="code">len</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">start</code> and <code class="code">len</code> do not designate a
    valid range of <code class="code">s</code>.<br>
</div>

<pre><span id="VALsub_string"><span class="keyword">val</span> sub_string</span> : <code class="type">bytes -> int -> int -> string</code></pre><div class="info ">
Same as <code class="code">sub</code> but return a string instead of a byte sequence.<br>
</div>

<pre><span id="VALfill"><span class="keyword">val</span> fill</span> : <code class="type">bytes -> pos:int -> len:int -> char -> unit</code></pre><div class="info ">
<code class="code">fill s start len c</code> modifies <code class="code">s</code> in place, replacing <code class="code">len</code>
    characters with <code class="code">c</code>, starting at <code class="code">start</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">start</code> and <code class="code">len</code> do not designate a
    valid range of <code class="code">s</code>.<br>
</div>

<pre><span id="VALblit"><span class="keyword">val</span> blit</span> : <code class="type">src:bytes -> src_pos:int -> dst:bytes -> dst_pos:int -> len:int -> unit</code></pre><div class="info ">
<code class="code">blit src srcoff dst dstoff len</code> copies <code class="code">len</code> bytes from sequence
    <code class="code">src</code>, starting at index <code class="code">srcoff</code>, to sequence <code class="code">dst</code>, starting at
    index <code class="code">dstoff</code>. It works correctly even if <code class="code">src</code> and <code class="code">dst</code> are the
    same byte sequence, and the source and destination intervals
    overlap.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">srcoff</code> and <code class="code">len</code> do not
    designate a valid range of <code class="code">src</code>, or if <code class="code">dstoff</code> and <code class="code">len</code>
    do not designate a valid range of <code class="code">dst</code>.<br>
</div>

<pre><span id="VALconcat"><span class="keyword">val</span> concat</span> : <code class="type">sep:bytes -> bytes list -> bytes</code></pre><div class="info ">
<code class="code">concat sep sl</code> concatenates the list of byte sequences <code class="code">sl</code>,
    inserting the separator byte sequence <code class="code">sep</code> between each, and
    returns the result as a new byte sequence.<br>
</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">f:(char -> unit) -> bytes -> unit</code></pre><div class="info ">
<code class="code">iter f s</code> applies function <code class="code">f</code> in turn to all the bytes of <code class="code">s</code>.
    It is equivalent to <code class="code">f (get s 0); f (get s 1); ...; f (get s
    (length s - 1)); ()</code>.<br>
</div>

<pre><span id="VALiteri"><span class="keyword">val</span> iteri</span> : <code class="type">f:(int -> char -> unit) -> bytes -> unit</code></pre><div class="info ">
Same as <a href="Bytes.html#VALiter"><code class="code">Bytes.iter</code></a>, but the function is applied to the index of
    the byte as first argument and the byte itself as second
    argument.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">f:(char -> char) -> bytes -> bytes</code></pre><div class="info ">
<code class="code">map f s</code> applies function <code class="code">f</code> in turn to all the bytes of <code class="code">s</code> and
    stores the resulting bytes in a new sequence that is returned as
    the result.<br>
</div>

<pre><span id="VALmapi"><span class="keyword">val</span> mapi</span> : <code class="type">f:(int -> char -> char) -> bytes -> bytes</code></pre><div class="info ">
<code class="code">mapi f s</code> calls <code class="code">f</code> with each character of <code class="code">s</code> and its
    index (in increasing index order) and stores the resulting bytes
    in a new sequence that is returned as the result.<br>
</div>

<pre><span id="VALtrim"><span class="keyword">val</span> trim</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, without leading and trailing
    whitespace. The bytes regarded as whitespace are the ASCII
    characters <code class="code">' '</code>, <code class="code">'\012'</code>, <code class="code">'\n'</code>, <code class="code">'\r'</code>, and <code class="code">'\t'</code>.<br>
</div>

<pre><span id="VALescaped"><span class="keyword">val</span> escaped</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, with special characters represented
    by escape sequences, following the lexical conventions of OCaml.<br>
</div>

<pre><span id="VALindex"><span class="keyword">val</span> index</span> : <code class="type">bytes -> char -> int</code></pre><div class="info ">
<code class="code">index s c</code> returns the index of the first occurrence of byte <code class="code">c</code>
    in <code class="code">s</code>.
<p>

    Raise <code class="code">Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code>.<br>
</div>

<pre><span id="VALrindex"><span class="keyword">val</span> rindex</span> : <code class="type">bytes -> char -> int</code></pre><div class="info ">
<code class="code">rindex s c</code> returns the index of the last occurrence of byte <code class="code">c</code>
    in <code class="code">s</code>.
<p>

    Raise <code class="code">Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code>.<br>
</div>

<pre><span id="VALindex_from"><span class="keyword">val</span> index_from</span> : <code class="type">bytes -> int -> char -> int</code></pre><div class="info ">
<code class="code">index_from s i c</code> returns the index of the first occurrence of
    byte <code class="code">c</code> in <code class="code">s</code> after position <code class="code">i</code>.  <code class="code">Bytes.index s c</code> is
    equivalent to <code class="code">Bytes.index_from s 0 c</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">i</code> is not a valid position in <code class="code">s</code>.
    Raise <code class="code">Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code> after position <code class="code">i</code>.<br>
</div>

<pre><span id="VALrindex_from"><span class="keyword">val</span> rindex_from</span> : <code class="type">bytes -> int -> char -> int</code></pre><div class="info ">
<code class="code">rindex_from s i c</code> returns the index of the last occurrence of
    byte <code class="code">c</code> in <code class="code">s</code> before position <code class="code">i+1</code>.  <code class="code">rindex s c</code> is equivalent
    to <code class="code">rindex_from s (Bytes.length s - 1) c</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">i+1</code> is not a valid position in <code class="code">s</code>.
    Raise <code class="code">Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code> before position <code class="code">i+1</code>.<br>
</div>

<pre><span id="VALcontains"><span class="keyword">val</span> contains</span> : <code class="type">bytes -> char -> bool</code></pre><div class="info ">
<code class="code">contains s c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code>.<br>
</div>

<pre><span id="VALcontains_from"><span class="keyword">val</span> contains_from</span> : <code class="type">bytes -> int -> char -> bool</code></pre><div class="info ">
<code class="code">contains_from s start c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code> after
    position <code class="code">start</code>.  <code class="code">contains s c</code> is equivalent to <code class="code">contains_from
    s 0 c</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">start</code> is not a valid position in <code class="code">s</code>.<br>
</div>

<pre><span id="VALrcontains_from"><span class="keyword">val</span> rcontains_from</span> : <code class="type">bytes -> int -> char -> bool</code></pre><div class="info ">
<code class="code">rcontains_from s stop c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code> before
    position <code class="code">stop+1</code>.
<p>

    Raise <code class="code">Invalid_argument</code> if <code class="code">stop &lt; 0</code> or <code class="code">stop+1</code> is not a valid
    position in <code class="code">s</code>.<br>
</div>

<pre><span id="VALuppercase"><span class="keyword">val</span> uppercase</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, with all lowercase letters
    translated to uppercase, including accented letters of the ISO
    Latin-1 (8859-1) character set.<br>
</div>

<pre><span id="VALlowercase"><span class="keyword">val</span> lowercase</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, with all uppercase letters
    translated to lowercase, including accented letters of the ISO
    Latin-1 (8859-1) character set.<br>
</div>

<pre><span id="VALcapitalize"><span class="keyword">val</span> capitalize</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, with the first byte set to
    uppercase.<br>
</div>

<pre><span id="VALuncapitalize"><span class="keyword">val</span> uncapitalize</span> : <code class="type">bytes -> bytes</code></pre><div class="info ">
Return a copy of the argument, with the first byte set to
    lowercase.<br>
</div>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = <code class="type">bytes</code> </pre>
<div class="info ">
An alias for the type of byte sequences.<br>
</div>


<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="BytesLabels.html#TYPEt">t</a> -> <a href="BytesLabels.html#TYPEt">t</a> -> int</code></pre><div class="info ">
The comparison function for byte sequences, with the same
    specification as <a href="Pervasives.html#VALcompare"><code class="code">Pervasives.compare</code></a>.  Along with the type <code class="code">t</code>,
    this function <code class="code">compare</code> allows the module <code class="code">Bytes</code> to be passed as
    argument to the functors <a href="Set.Make.html"><code class="code">Set.Make</code></a> and <a href="Map.Make.html"><code class="code">Map.Make</code></a>.<br>
</div>
</body></html>