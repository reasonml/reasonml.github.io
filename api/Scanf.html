<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAnhJREFUWAljvOtj+Z9hoAAj42OmgbIbZu+oA0ZDYDQERkNgNARGQ2A0BFhg1SJOmpmZgZGJGUX6/39gE+LPbxQxZA4jKxsyFyv7/98/DAxAcwg6QLy8hYHb0h7DkL9fPjH8fvaE4fOuzQyfd29hYPj3F6yGWUCQQX7xVgz16AKvJ3cA9W0m7AB0jTA+Mw8fA7OaFgMHEHNb2DK8aCyBSZFEEwwBZNO+nTvJ8OPaRQYGRkYGVkkZBh47VwZGFhYGLhMrBh5HD4Yv+3cgKwez36+Yx/D/DzC40cDPOzfAIiQ54PvF0wwf1y2DG/Xr0X0G4YQsMJ9DWx+rAz6sXcrw/8d3uB4UBtAjJDkARTOQ8/vhPbgQs4AwnI3MADns/8+fyEIM/759Zfh17xZYjHwHAHMHj5Mn3OA/L5/C2cgMyYY+ZC6Y/ePGFYZnpWlgNkkO4PcLZ+CxdQFqBAadmAQDMx8/2JD/f/8yfN67HcwmlSDJASzCogwgjAxACezNrD54kCLLgdgvmkvBUQDufIDKDyD49/UzmAYRJDng19NHDH9ePmNgZOdg4NQ2ABvyGyj2eedmuIHojO+XzuFOhKQ64POuTfBcIN03l4FdVZOBTV6JgT8wkuHj2iXodoP5/D4h2LPh3ZsMP66cJy0EkG14t3gmg2TTBLCQYGQyw9ej+xn+vMBMiELxmcja4OyPm1aBHUB2bfj9/CmG75fPgw1kYmdnEMkugxtOCoORUOeUkYMTXNqBDAXl5/+/f8HNB1U6jEDLYeDfF0jiYuLhhQnhpEHm/P/16zHBRAgqxSBpF9MssCFIDoKpgDkExsdJg0tCRoaPOBXQXuITAIHczlO/UBn+AAAAAElFTkSuQmCC"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="preload" href="/page-component---src-templates-api-js-4acaaa9e8b59a96c1a64.js" as="script"/><link rel="preload" href="/path---api-scanf-html-8a3b94e4b6e659d16e80.js" as="script"/><link rel="preload" href="/layout-component---index-1726cc9c43958b0994ee.js" as="script"/><link rel="preload" href="/app-5db2fd34890d9bf3b80d.js" as="script"/><link rel="preload" href="/commons-17e6a4325268feea835d.js" as="script"/><script id="webpack-manifest">
            //<![CDATA[
            window.webpackManifest = {"1":"page-component---src-templates-guide-js-389e4ace8a7ea50a7c15.js","2":"page-component---src-pages-index-js-9ef392ccc152c49ddadc.js","3":"page-component---src-pages-try-js-6993433e05b619070b48.js","4":"page-component---src-pages-community-examples-js-e582deed4be252ecead9.js","5":"page-component---src-templates-api-js-4acaaa9e8b59a96c1a64.js","6":"layout-component---index-1726cc9c43958b0994ee.js","7":"page-component---src-templates-search-js-f9a40f5a05952b6f3cbf.js","8":"path---try-586c7e095e534a3909ec.js","9":"path---index-088e597fc136add51ada.js","10":"path---guide-a594c006f2fe37b37028.js","11":"path---guide-tools-976aa9dcb8480182c5e4.js","12":"path---guide-search-e1996f311c9edd742d35.js","13":"path---guide-ocaml-ab2962f297f62a71d49f.js","14":"path---guide-native-a671a489e450022b3000.js","15":"path---guide-native-quickstart-dc25f043fd2fa174bab1.js","16":"path---guide-native-convert-from-ocaml-7c9a9819fc4a5bf6fe80.js","17":"path---guide-language-818b5d3e6bec3b40f701.js","18":"path---guide-language-types-e36bfb9977468e2e3d8c.js","19":"path---guide-language-primitives-559ab4d86dbdff992d0c.js","20":"path---guide-language-mutation-9e4b0401835d22a6225b.js","21":"path---guide-language-more-types-aebdc5c70057bbab31e2.js","22":"path---guide-language-more-functions-9847672140da09c69630.js","23":"path---guide-language-modules-8d12688f2698cfca9853.js","24":"path---guide-language-let-bindings-4e5266c7c13ffb619222.js","25":"path---guide-language-jsx-2796d11eb5feb800d276.js","26":"path---guide-language-imperative-loops-f018e8250a476f96fbdb.js","27":"path---guide-language-functions-d3b153d862b0438a1993.js","28":"path---guide-language-externals-537ad6a53dffacaff474.js","29":"path---guide-language-destructuring-f62a0bacb7d595820a15.js","30":"path---guide-language-data-types-ceea046e6d66346d30be.js","31":"path---guide-language-conditionals-a3b4b1bff2ea01eb0559.js","32":"path---guide-javascript-b0f9a42681530ba00b7e.js","33":"path---guide-javascript-syntax-cheetsheet-e88caa9b4099422a9b8b.js","34":"path---guide-javascript-quickstart-0f51f44f951a861d92b9.js","35":"path---guide-javascript-libraries-6f23e9507c5c6eb31e04.js","36":"path---guide-javascript-interop-f341d914e74e537be2e6.js","37":"path---guide-javascript-converting-452ce7f82f6ab06f6859.js","38":"path---guide-getting-started-ae22be5e93a3449d3663.js","39":"path---guide-examples-fc649ee776082a877e21.js","40":"path---guide-editor-setup-8fb3a520e50c09b8c461.js","41":"path---community-135affbdc20f543c2689.js","42":"path---community-search-bb8ea90d520f2e61bc90.js","43":"path---community-roadmap-347ba33b385b02251cf2.js","44":"path---community-faq-ff6748f59940fefed285.js","45":"path---community-examples-5da5a6bf175f27f83aac.js","46":"path---community-events-fb61a16e152cc96a3e32.js","47":"path---community-blog-58ae31dbb88b24f0fa19.js","48":"path---community-articles-and-videos-889a93fa64dd8aab4d38.js","49":"path---api-weak-s-html-ca19bc1edb39c9ebccff.js","50":"path---api-weak-make-html-fe110b603633c0841f95.js","51":"path---api-weak-html-fc8a1277dd79d0a33069.js","52":"path---api-unix-large-file-html-0afa959d834f2b91977f.js","53":"path---api-unix-html-81e15fff7dc57631ae62.js","54":"path---api-type-weak-s-html-eaa672cf7769fba37815.js","55":"path---api-type-weak-make-html-8447f98a3fb2a2d85d6a.js","56":"path---api-type-weak-html-851cad038f404caf5c15.js","57":"path---api-type-unix-large-file-html-74db4d3ce80a235f2509.js","58":"path---api-type-unix-html-7ce3173c9eb0e19f743a.js","59":"path---api-type-sys-html-a8c382f2c311c0855c55.js","60":"path---api-type-syntaxerr-html-2f17baa7fff901e9cc70.js","61":"path---api-type-string-labels-html-6b374bfcca02108dcf8b.js","62":"path---api-type-string-html-0fbf29632de710fa41b6.js","63":"path---api-type-stream-html-fe54fc277bcf16bd0148.js","64":"path---api-type-str-html-8e382733f09b8131b528.js","65":"path---api-type-std-labels-string-html-cb7dbe0a0f36af12591a.js","66":"path---api-type-std-labels-list-html-ba43b603d77a2b047b9e.js","67":"path---api-type-std-labels-html-c1351413589934c44c62.js","68":"path---api-type-std-labels-bytes-html-bd004222d119404dee6b.js","69":"path---api-type-std-labels-array-html-98d38ba9e5dd8e991e8b.js","70":"path---api-type-stack-html-6e7587a7c2949df87086.js","71":"path---api-type-sort-html-a636b76af113affc440c.js","72":"path---api-type-set-s-html-d6eeb23966812accdb31.js","73":"path---api-type-set-ordered-type-html-1e8b7d3051dc9fc81b04.js","74":"path---api-type-set-make-html-08b82ad1a5241cd1887a.js","75":"path---api-type-set-html-7e211826fad067bd0236.js","76":"path---api-type-scanf-scanning-html-57cf208f702cef1979bc.js","77":"path---api-type-scanf-html-192ea3a0f3cc07f62b73.js","78":"path---api-type-random-state-html-9592c29dd091e158e7ea.js","79":"path---api-type-random-html-3f18853ea95f1f1aecd7.js","80":"path---api-type-queue-html-5d3b5720aa483492779c.js","81":"path---api-type-printf-html-15b2bcb5e160da125b4d.js","82":"path---api-type-printexc-slot-html-aafb6a36fde8938c884b.js","83":"path---api-type-printexc-html-d343b9687b819bb10f72.js","84":"path---api-type-printast-html-078501db5e46351d7cbd.js","85":"path---api-type-pprintast-printer-html-627557e25c5a84f7a82a.js","86":"path---api-type-pprintast-html-a74be3996fb2e3508bda.js","87":"path---api-type-pervasives-large-file-html-ff4eb2c0eea9cdcf98d8.js","88":"path---api-type-pervasives-html-e67b39caddc09e4bbc9b.js","89":"path---api-type-parsing-html-978dc8de140914dbe035.js","90":"path---api-type-parsetree-html-0c76f18445ae6089cbd6.js","91":"path---api-type-parser-html-58037886992cdb4ce413.js","92":"path---api-type-parse-html-a3d0caf43f2639bdf1c7.js","93":"path---api-type-oo-html-c4f3a5827235c11d844e.js","94":"path---api-type-obj-html-71b78ae80f00ed4c2cac.js","95":"path---api-type-num-html-0727969d94157e2f50c6.js","96":"path---api-type-nativeint-html-a8910438545a692b8aec.js","97":"path---api-type-more-labels-set-s-html-806384ad055e9b60e152.js","98":"path---api-type-more-labels-set-ordered-type-html-da2a019518473e99ac62.js","99":"path---api-type-more-labels-set-make-html-c5cd0e8b7db9e46ff36a.js","100":"path---api-type-more-labels-set-html-0813cd1e122ef99fcfa0.js","101":"path---api-type-more-labels-map-s-html-22e08943167bdc6d6c3f.js","102":"path---api-type-more-labels-map-ordered-type-html-7154a7b3596679fccfcb.js","103":"path---api-type-more-labels-map-make-html-0c0c3984d3c8887c44fc.js","104":"path---api-type-more-labels-map-html-8178c30c7d08e6a8aea0.js","105":"path---api-type-more-labels-html-9554e4f5be23a41fff92.js","106":"path---api-type-more-labels-hashtbl-seeded-s-html-0266426deb6450d73c59.js","107":"path---api-type-more-labels-hashtbl-seeded-hashed-type-html-ece8d726b22612ac0914.js","108":"path---api-type-more-labels-hashtbl-s-html-9882e40154b400d47850.js","109":"path---api-type-more-labels-hashtbl-make-seeded-html-c9aa1fd01fb9ba27cac0.js","110":"path---api-type-more-labels-hashtbl-make-html-849a13f7f13d3a9086cf.js","111":"path---api-type-more-labels-hashtbl-html-5e5ad16c84d6dd88f5b6.js","112":"path---api-type-more-labels-hashtbl-hashed-type-html-0649deaec623969e3e95.js","113":"path---api-type-marshal-html-b7b9c473e475f26255b7.js","114":"path---api-type-map-s-html-4aa14345ea4bb1e26068.js","115":"path---api-type-map-ordered-type-html-88c0ccfdf3c759e044d4.js","116":"path---api-type-map-make-html-95c06d43c4f6b1467fb2.js","117":"path---api-type-map-html-84f627b75db5f7768c70.js","118":"path---api-type-longident-html-f7f28e6f2d505a86d1fb.js","119":"path---api-type-location-html-7e3e070c7f0d160c5380.js","120":"path---api-type-list-labels-html-40ae105f7cb136a9b178.js","121":"path---api-type-list-html-d19dc2d348813b0f01d9.js","122":"path---api-type-lexing-html-344fec4cfe8caf865ec6.js","123":"path---api-type-lexer-html-573a8cd850f380f31a07.js","124":"path---api-type-lazy-html-c6add305db565523d427.js","125":"path---api-type-int-64-html-d3c20aa8ea64f315d79e.js","126":"path---api-type-int-32-html-2acc0ff3ba272332cff4.js","127":"path---api-type-hashtbl-seeded-s-html-c585cae8e0243c4b549a.js","128":"path---api-type-hashtbl-seeded-hashed-type-html-802db55708531de770c8.js","129":"path---api-type-hashtbl-s-html-ea4d2312eb818fad39e6.js","130":"path---api-type-hashtbl-make-seeded-html-f86c19b364882b6994f1.js","131":"path---api-type-hashtbl-make-html-a4222e70e1271b99ddc1.js","132":"path---api-type-hashtbl-html-4c8833f537511faea896.js","133":"path---api-type-hashtbl-hashed-type-html-1246409be70452643a23.js","134":"path---api-type-genlex-html-da8865fbb07da657d8c0.js","135":"path---api-type-gc-html-d119717227409a466010.js","136":"path---api-type-format-html-615f2f901ba313f88b99.js","137":"path---api-type-filename-html-0c2e8592117732a137dd.js","138":"path---api-type-docstrings-html-bba24867dc17324ce7eb.js","139":"path---api-type-digest-html-916e815d5c61fd8c9bc5.js","140":"path---api-type-complex-html-38f65366a83c375c3a6e.js","141":"path---api-type-char-html-4d87379fa6128d374d4d.js","142":"path---api-type-camlinternal-oo-html-327f9048f8c152e83d44.js","143":"path---api-type-camlinternal-mod-html-d5721238e9d438e113b5.js","144":"path---api-type-camlinternal-lazy-html-3057d101f9910eebeb67.js","145":"path---api-type-camlinternal-format-html-105b2b663795452705e9.js","146":"path---api-type-camlinternal-format-basics-html-db3ca061ff7ec173abe0.js","147":"path---api-type-callback-html-e4bba0c6771251858efb.js","148":"path---api-type-bytes-labels-html-7a2e16aada3293c3002b.js","149":"path---api-type-bytes-html-99d3a0d7b67484e5dbe3.js","150":"path---api-type-buffer-html-8828145cf7aa57b10668.js","151":"path---api-type-bigarray-html-3b26988a6de6a81cf726.js","152":"path---api-type-bigarray-genarray-html-6c6f7270655b90e99715.js","153":"path---api-type-bigarray-array-3-html-6928e27f2a4a2d8e5372.js","154":"path---api-type-bigarray-array-2-html-9ec45fd0a1a65b62fa56.js","155":"path---api-type-bigarray-array-1-html-92d2b683ddd9e937f732.js","156":"path---api-type-asttypes-html-14ac682c1a4da40be0c5.js","157":"path---api-type-ast-mapper-html-1f75d5bf2b7904afe74b.js","158":"path---api-type-ast-helper-vb-html-81371bab3cd0b92accef.js","159":"path---api-type-ast-helper-val-html-217875d29691f0d54787.js","160":"path---api-type-ast-helper-type-html-c215563b727d59a3b640.js","161":"path---api-type-ast-helper-typ-html-ea118b75de83cf41ae9e.js","162":"path---api-type-ast-helper-te-html-6fd338613fd207cc30b8.js","163":"path---api-type-ast-helper-str-html-fcc9736b6e943e916c74.js","164":"path---api-type-ast-helper-sig-html-b86d22ce859ce12a776c.js","165":"path---api-type-ast-helper-pat-html-2f68a4ea4b410735cda7.js","166":"path---api-type-ast-helper-opn-html-db987e850bba20e1eee0.js","167":"path---api-type-ast-helper-mty-html-84c5f038bc9fb30d7fdb.js","168":"path---api-type-ast-helper-mtd-html-b988087dec8e9dd4718a.js","169":"path---api-type-ast-helper-mod-html-08891dd66eba2f2e7c3d.js","170":"path---api-type-ast-helper-md-html-cd704f330f8730241dc5.js","171":"path---api-type-ast-helper-mb-html-5e057449232f79e95aca.js","172":"path---api-type-ast-helper-incl-html-10162a8d057feb2c3876.js","173":"path---api-type-ast-helper-html-57ea4361854b1c185946.js","174":"path---api-type-ast-helper-exp-html-a158f4563e3366c437e5.js","175":"path---api-type-ast-helper-cty-html-df1c2d7dcce3764d308c.js","176":"path---api-type-ast-helper-ctf-html-77a6bd84963c0a8a9687.js","177":"path---api-type-ast-helper-cstr-html-65f8aec60837eca970fd.js","178":"path---api-type-ast-helper-csig-html-2e3672038e9d09dd9eba.js","179":"path---api-type-ast-helper-cl-html-9c2a4922b95fd9ea6334.js","180":"path---api-type-ast-helper-ci-html-7ba61af793a7d66eefe9.js","181":"path---api-type-ast-helper-cf-html-b25776c5eea3820128b4.js","182":"path---api-type-array-labels-html-0f8c3364cdd3b7432ef5.js","183":"path---api-type-array-html-03370d8dc1d89f406c9f.js","184":"path---api-type-arg-html-32b863f83de3d15bd252.js","185":"path---api-sys-html-195a3611314b4232133b.js","186":"path---api-syntaxerr-html-a1beb3c2a96e9789c5be.js","187":"path---api-string-labels-html-71f27f41d8d0fe8f0556.js","188":"path---api-string-html-b75fc77aaf943330ff92.js","189":"path---api-stream-html-b3c50d658ce2b75b774d.js","190":"path---api-str-html-559f2d5d1fc7a4245bcc.js","191":"path---api-std-labels-string-html-1776caa7938937e4c86e.js","192":"path---api-std-labels-list-html-11cc2d4a50b97a7ea07a.js","193":"path---api-std-labels-html-d187a0e27a8bde27d612.js","194":"path---api-std-labels-bytes-html-7f9858074a01015c1083.js","195":"path---api-std-labels-array-html-401309e93984f0ccaa4a.js","196":"path---api-stack-html-be59dde11c1b3d678e94.js","197":"path---api-sort-html-4f9676b39a1c41388153.js","198":"path---api-set-s-html-284966a26175a675879b.js","199":"path---api-set-ordered-type-html-57bd651c30c64733225d.js","200":"path---api-set-make-html-ab57b4feeff96aa35296.js","201":"path---api-set-html-bf45513e9e99af21b6ee.js","202":"path---api-scanf-scanning-html-58316a86ee19be21d906.js","203":"path---api-scanf-html-8a3b94e4b6e659d16e80.js","204":"path---api-random-state-html-809eed2926db6d2db241.js","205":"path---api-random-html-83e38c304f9706eb9192.js","206":"path---api-queue-html-744c61e5b2853dff5f45.js","207":"path---api-printf-html-c46c40d3382e1afb69b0.js","208":"path---api-printexc-slot-html-4a903ab2f2831e5df318.js","209":"path---api-printexc-html-699309622f9854170819.js","210":"path---api-printast-html-9ad7fbfbc2a928adbc95.js","211":"path---api-pprintast-printer-c-html-6c9e9c6a996a9b359a73.js","212":"path---api-pprintast-html-f8be747c9d35acb58ff1.js","213":"path---api-pervasives-large-file-html-2a1a02bad289a1a3a3f4.js","214":"path---api-pervasives-html-1300e25097c4589b541e.js","215":"path---api-parsing-html-ac8f76b0e47be90f8977.js","216":"path---api-parsetree-html-f167f9eb0d0143370d09.js","217":"path---api-parser-html-6fc1ad0ddc68c0d83f4e.js","218":"path---api-parse-html-de2ff9addd6c150d8fcb.js","219":"path---api-oo-html-374b94f662bf46b00cc2.js","220":"path---api-obj-html-458dbd745e5e75f3cf81.js","221":"path---api-num-html-61497237940885d5a614.js","222":"path---api-nativeint-html-64bd7e704f67bfe6178c.js","223":"path---api-more-labels-set-s-html-4ed5d2fad6cea319aa5b.js","224":"path---api-more-labels-set-ordered-type-html-71cec87552aa46000e87.js","225":"path---api-more-labels-set-make-html-c5b386a484016c833b0d.js","226":"path---api-more-labels-set-html-8ef36b8d5132ee9e5964.js","227":"path---api-more-labels-map-s-html-fe2f386a0bad8c4cc5c3.js","228":"path---api-more-labels-map-ordered-type-html-87f8eb74bafdf4f2e78d.js","229":"path---api-more-labels-map-make-html-3cde51d2c4542c378ce8.js","230":"path---api-more-labels-map-html-f91b98441d808a104200.js","231":"path---api-more-labels-html-4db6cbc14a94dfede624.js","232":"path---api-more-labels-hashtbl-seeded-s-html-8c322d086df8c9ec071d.js","233":"path---api-more-labels-hashtbl-seeded-hashed-type-html-cd0104b15413747eb09c.js","234":"path---api-more-labels-hashtbl-s-html-a23664d0cf74cce1495e.js","235":"path---api-more-labels-hashtbl-make-seeded-html-d8a97ea55c3d37c0ba23.js","236":"path---api-more-labels-hashtbl-make-html-2d7867bd458fbd14ba38.js","237":"path---api-more-labels-hashtbl-html-52568a49b5f0efe7ed44.js","238":"path---api-more-labels-hashtbl-hashed-type-html-12f02ab72d38b7cc6f40.js","239":"path---api-marshal-html-1a640a2db4c6eb383d51.js","240":"path---api-map-s-html-d04c0404fe0527df1cd3.js","241":"path---api-map-ordered-type-html-2ac37cbaf9a0bb348bbf.js","242":"path---api-map-make-html-cb62144b379d7c503dd5.js","243":"path---api-map-html-1fcdcec7d2ac2083523f.js","244":"path---api-longident-html-9b377f9d1e7eaaec7c03.js","245":"path---api-location-html-a6947e4c23d5531c9581.js","246":"path---api-list-labels-html-a800de5d21a656358495.js","247":"path---api-list-html-9ef8ca9a31d61501e5b5.js","248":"path---api-lexing-html-6e0003954a5a27450e6f.js","249":"path---api-lexer-html-cec850a6438201b599dc.js","250":"path---api-lazy-html-9ae863b2c1ace2143e76.js","251":"path---api-int-64-html-b785799ef690f8eaff50.js","252":"path---api-int-32-html-927e89bd4b251a78817d.js","253":"path---api-index-values-html-d12d1a3803145d2848e6.js","254":"path---api-index-types-html-21d8478a4b339081f837.js","255":"path---api-index-modules-html-f72c389dd0f1a93f2967.js","256":"path---api-index-module-types-html-3179739d03715a8a2ce7.js","257":"path---api-index-methods-html-6398bf4b7126e4800d29.js","258":"path---api-index-html-57d694de2a6fdc29acd7.js","259":"path---api-index-extensions-html-e792cfa24d213a58c0b7.js","260":"path---api-index-exceptions-html-114af2f5dcfd9949fe9c.js","261":"path---api-index-classes-html-d135d4580a66cf1f8fab.js","262":"path---api-index-class-types-html-017343ce364c58908028.js","263":"path---api-index-attributes-html-2cc002255476fa454bce.js","264":"path---api-hashtbl-seeded-s-html-cbf1f87a8a6fa8e5d3fd.js","265":"path---api-hashtbl-seeded-hashed-type-html-c393db4f8df3cfd0f7d7.js","266":"path---api-hashtbl-s-html-c82afb872ea3c1e26ed1.js","267":"path---api-hashtbl-make-seeded-html-7f7bc2ced1a4fc758dcb.js","268":"path---api-hashtbl-make-html-50f179c81e18ac928d9c.js","269":"path---api-hashtbl-html-51a37a27a991493e0bc6.js","270":"path---api-hashtbl-hashed-type-html-c01ad8402df00b7df204.js","271":"path---api-genlex-html-a328c0920610c8db6d46.js","272":"path---api-gc-html-6f6c0ffab8f99d6c254c.js","273":"path---api-format-html-760b6875fa948bdfc4b6.js","274":"path---api-filename-html-410b61d21cba38958e0e.js","275":"path---api-docstrings-html-fd49ec52a65d7fa1e364.js","276":"path---api-digest-html-a2f2a9b0b6b79ec31879.js","277":"path---api-complex-html-5bcb3566929e3e0685e2.js","278":"path---api-char-html-c71bc61acd98b04878a6.js","279":"path---api-camlinternal-oo-html-1bbbdad2bb546fa79780.js","280":"path---api-camlinternal-mod-html-c450a8bf042fcb3ffc20.js","281":"path---api-camlinternal-lazy-html-c5ce975d9e312154495b.js","282":"path---api-camlinternal-format-html-9cc61d98b892b3385438.js","283":"path---api-camlinternal-format-basics-html-9371fc4e306ce34e94df.js","284":"path---api-callback-html-9ef2f93bf43341a49768.js","285":"path---api-bytes-labels-html-1f1a1886b97abccf4b3b.js","286":"path---api-bytes-html-90e04ee29275a12cfbf0.js","287":"path---api-buffer-html-aa45632dcee68caf5470.js","288":"path---api-bigarray-html-6da7a1a318d36b34759c.js","289":"path---api-bigarray-genarray-html-4734b8104069d037790b.js","290":"path---api-bigarray-array-3-html-a8ab12ccbf16d32d4552.js","291":"path---api-bigarray-array-2-html-6d238e3feac09da16ae5.js","292":"path---api-bigarray-array-1-html-fae711bdd6f29ceada6d.js","293":"path---api-asttypes-html-7f17c2e8998658633d43.js","294":"path---api-ast-mapper-html-5baa7f074ef5fe0d035c.js","295":"path---api-ast-helper-vb-html-f6d69591b1f830943139.js","296":"path---api-ast-helper-val-html-8371215ca86ea57f3db2.js","297":"path---api-ast-helper-type-html-7f37c5545ac6950d9de5.js","298":"path---api-ast-helper-typ-html-c25a2d80bd03f4dff74f.js","299":"path---api-ast-helper-te-html-0efeea37d6051a54a2ad.js","300":"path---api-ast-helper-str-html-7388ea8a52755c30687b.js","301":"path---api-ast-helper-sig-html-1f82a8ac4c00645a0c5d.js","302":"path---api-ast-helper-pat-html-d55a25bcd76d81c0fab0.js","303":"path---api-ast-helper-opn-html-d803861a99200a054378.js","304":"path---api-ast-helper-mty-html-fe5d7e49d9b958968616.js","305":"path---api-ast-helper-mtd-html-0f8e8bd97f95c556fa34.js","306":"path---api-ast-helper-mod-html-b4dc177bdfdd4dc61c63.js","307":"path---api-ast-helper-md-html-2fffb661486f984f33f4.js","308":"path---api-ast-helper-mb-html-78259780790444b71338.js","309":"path---api-ast-helper-incl-html-f08286f2ff13b8e35eeb.js","310":"path---api-ast-helper-html-a3feaa57c8d57ccb65df.js","311":"path---api-ast-helper-exp-html-8bc40f03b788bd99101a.js","312":"path---api-ast-helper-cty-html-51f7759cf057545451bd.js","313":"path---api-ast-helper-ctf-html-899cc393e17818c99225.js","314":"path---api-ast-helper-cstr-html-43ea0942644618081f7e.js","315":"path---api-ast-helper-csig-html-0546a2c4b3ce3e0773ff.js","316":"path---api-ast-helper-cl-html-af1cba34937d439aed34.js","317":"path---api-ast-helper-ci-html-7bafc151cde702dd305d.js","318":"path---api-ast-helper-cf-html-505ecb40b014508f4887.js","319":"path---api-array-labels-html-298884585fece2c8eb56.js","320":"path---api-array-html-027ebfe9b9475580e76a.js","321":"path---api-arg-html-7caa20266613b20aa25d.js","322":"app-5db2fd34890d9bf3b80d.js"}
            //]]>
            </script><title data-react-helmet="true">Standard Library API</title><style type="text/css">
    .anchor {
      float: left;
      padding-right: 4px;
      margin-left: -20px;
    }
    h1 .anchor svg,
    h2 .anchor svg,
    h3 .anchor svg,
    h4 .anchor svg,
    h5 .anchor svg,
    h6 .anchor svg {
      visibility: hidden;
    }
    h1:hover .anchor svg,
    h2:hover .anchor svg,
    h3:hover .anchor svg,
    h4:hover .anchor svg,
    h5:hover .anchor svg,
    h6:hover .anchor svg {
      visibility: visible;
    }
  </style><script>
    document.addEventListener("DOMContentLoaded", function(event) {
      var hash = location.hash.replace('#', '')
      if (hash !== '') {
        var element = document.getElementById(hash)
        if (element) {
          var offset = element.offsetTop
          // Wait for the browser to finish rendering before scrolling.
          setTimeout((function() {
            window.scrollTo(0, offset - 0)
          }), 0)
        }
      }
    })
  </script><script>
  !function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",[
  "/commons-17e6a4325268feea835d.js","/app-5db2fd34890d9bf3b80d.js","/layout-component---index-1726cc9c43958b0994ee.js","/path---api-scanf-html-8a3b94e4b6e659d16e80.js","/page-component---src-templates-api-js-4acaaa9e8b59a96c1a64.js"
])
  </script><style id="typography.js">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em Merriweather,Book Antiqua,Georgia,Century Schoolbook,serif;box-sizing:border-box;overflow-y:scroll;}*{box-sizing:inherit;}*:before{box-sizing:inherit;}*:after{box-sizing:inherit;}body{color:hsla(0,0%,0%,0.8);font-family:Merriweather,Book Antiqua,Georgia,Century Schoolbook,serif;font-weight:normal;word-wrap:break-word;font-kerning:normal;-moz-font-feature-settings:"kern", "liga", "clig", "calt";-ms-font-feature-settings:"kern", "liga", "clig", "calt";-webkit-font-feature-settings:"kern", "liga", "clig", "calt";font-feature-settings:"kern", "liga", "clig", "calt";}img{max-width:100%;margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}h1{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:2.25rem;line-height:2.9rem;}h2{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.62671rem;line-height:2.175rem;}h3{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1.38316rem;line-height:2.175rem;}h4{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:1rem;line-height:1.45rem;}h5{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.85028rem;line-height:1.45rem;}h6{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:bold;text-rendering:optimizeLegibility;font-size:0.78405rem;line-height:1.45rem;}hgroup{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}ul{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}ol{margin-left:1.45rem;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;list-style-position:outside;list-style-image:none;}dl{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}dd{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}p{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}figure{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}pre{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:0.85rem;line-height:1.42;background:hsla(0,0%,0%,0.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem;}table{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%;}fieldset{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}blockquote{margin-left:1.45rem;margin-right:1.45rem;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}form{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}noscript{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}iframe{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}hr{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:calc(1.45rem - 1px);background:hsla(0,0%,0%,0.2);border:none;height:1px;}address{margin-left:0;margin-right:0;margin-top:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;margin-bottom:1.45rem;}b{font-weight:bold;}strong{font-weight:bold;}dt{font-weight:bold;}th{font-weight:bold;}li{margin-bottom:calc(1.45rem / 2);}ol li{padding-left:0;}ul li{padding-left:0;}li > ol{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}li > ul{margin-left:1.45rem;margin-bottom:calc(1.45rem / 2);margin-top:calc(1.45rem / 2);}blockquote *:last-child{margin-bottom:0;}li *:last-child{margin-bottom:0;}p *:last-child{margin-bottom:0;}li > p{margin-bottom:calc(1.45rem / 2);}code{font-size:0.85rem;line-height:1.45rem;}kbd{font-size:0.85rem;line-height:1.45rem;}samp{font-size:0.85rem;line-height:1.45rem;}abbr{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}acronym{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;}abbr[title]{border-bottom:1px dotted hsla(0,0%,0%,0.5);cursor:help;text-decoration:none;}thead{text-align:left;}td,th{text-align:left;border-bottom:1px solid hsla(0,0%,0%,0.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding-left:0.96667rem;padding-right:0.96667rem;padding-top:0.725rem;padding-bottom:calc(0.725rem - 1px);}th:first-child,td:first-child{padding-left:0;}th:last-child,td:last-child{padding-right:0;}tt,code{background-color:hsla(0,0%,0%,0.04);border-radius:3px;font-family:"SFMono-Regular", Consolas,"Roboto Mono","Droid Sans Mono","Liberation Mono",Menlo,Courier,monospace;padding:0;padding-top:0.2em;padding-bottom:0.2em;}pre code{background:none;line-height:1.42;}code:before,code:after,tt:before,tt:after{letter-spacing:-0.2em;content:"Â ";}pre code:before,pre code:after,pre tt:before,pre tt:after{content:"";}@media only screen and (max-width:480px){html{font-size:100%;}}</style><style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#fff;color:#000;-webkit-text-size-adjust:none}.hljs-comment{color:#006a00}.hljs-keyword,.hljs-literal,.nginx .hljs-title{color:#aa1094}.hljs-list .hljs-title,.hljs-name,.hljs-request,.hljs-status,.hljs-tag .hljs-title,.hljs-winutils,.http .hljs-title,.method,.setting .hljs-value,.tex .hljs-command{color:#008}.hljs-envvar,.tex .hljs-special{color:#660}.hljs-string{color:#c41a16}.apache .hljs-cbracket,.hljs-attr_selector,.hljs-cdata,.hljs-date,.hljs-filter .hljs-argument,.hljs-regexp,.hljs-tag .hljs-value{color:#080}.coffeescript .hljs-attribute,.css .hljs-function,.hljs-decorator,.hljs-function .hljs-title,.hljs-hexcolor,.hljs-number,.hljs-pi,.hljs-prompt,.hljs-rule .hljs-value,.hljs-shebang,.hljs-sub .hljs-identifier,.hljs-symbol,.hljs-symbol .hljs-string,.hljs-tag,.hljs-tag .hljs-keyword,.ini .hljs-title{color:#1c00cf}.clojure .hljs-attribute,.hljs-built_in,.hljs-class .hljs-id,.hljs-class .hljs-title,.hljs-doctype,.hljs-tag .hljs-attribute,.hljs-type,.hljs-typename,.setting,.smalltalk .hljs-class{color:#5b2f8e}.hljs-params,.hljs-variable{color:#3f6e74}.css .hljs-tag,.hljs-pseudo,.hljs-rule .hljs-property,.hljs-subst{color:#000}.css .hljs-class,.css .hljs-id{color:#9b703f}.hljs-value .hljs-important{color:#f70;font-weight:700}.hljs-rule .hljs-keyword{color:#c5af75}.apache .hljs-sqbracket,.hljs-annotation,.nginx .hljs-built_in{color:#9b859d}.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor *{color:#643820}.tex .hljs-formula{background-color:#eee;font-style:italic}.diff .hljs-header,.hljs-chunk{color:gray;font-weight:700}.diff .hljs-change{background-color:#bccff9}.hljs-addition{background-color:#baeeba}.hljs-deletion{background-color:#ffc8bd}.hljs-comment .hljs-doctag{font-weight:700}.method .hljs-id{color:#000}.hljs{background:#fbfafa;border:1px solid #eee;display:block;padding:10px;border-radius:1px;overflow:auto}td>pre{padding:5px 15px;margin:0}.ocamldoc{padding-top:24px;font-size:100%;line-height:1.8rem}.ocamldoc div{display:block}.ocamldoc pre{margin:0;margin:initial;padding:0;padding:initial;background:transparent none repeat 0 0/auto auto padding-box border-box scroll;background:initial;border-radius:0;border-radius:initial;overflow:visible;overflow:initial;word-wrap:normal;font-size:112.5%}.ocamldoc code{font-size:medium;line-height:normal}.ocamldoc .keyword{color:#aa1094}.ocamldoc .keywordsign{color:#c41a16}.ocamldoc .comment{color:#006a00}.ocamldoc .constructor,.ocamldoc .type{color:#5b2f8e}.ocamldoc .string{color:#c41a16}.ocamldoc .warning{color:red;font-weight:700}.ocamldoc .info,.ocamldoc .param_info{margin-left:3em;margin-right:3em}.ocamldoc .param_info{margin-top:4px}.ocamldoc .code{background:#fbfafa;border:1px solid #eee;padding:2px;border-radius:1px;overflow:auto}.ocamldoc .typetable{border-style:hidden;width:auto}.ocamldoc .paramstable{border-style:hidden;padding:5pt}.ocamldoc tr{background-color:#fff}.ocamldoc td{border:none;padding:0}.ocamldoc td.typefieldcomment{background-color:#fff;font-size:smaller}.ocamldoc div.sig_block{margin-left:2em}.ocamldoc :target{background:#ff0}.ocamldoc h1,.ocamldoc h2{margin-bottom:1.45rem;font-size:1.62671rem;line-height:2.175rem;border-bottom:1px solid #aaa}.ocamldoc .h7,.ocamldoc .h8,.ocamldoc .h9,.ocamldoc h1,.ocamldoc h2,.ocamldoc h3,.ocamldoc h4,.ocamldoc h5,.ocamldoc h6{color:inherit;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;font-weight:700;text-rendering:optimizeLegibility}.ocamldoc .h7,.ocamldoc .h8,.ocamldoc .h9,.ocamldoc h3,.ocamldoc h4,.ocamldoc h5,.ocamldoc h6{margin:0;margin-top:1em;margin-bottom:1rem;padding:0;font-size:1.3rem;line-height:1.45rem}.ocamldoc a{color:#db4d3f;text-decoration:none}.ocamldoc a:hover{text-decoration:underline}.ocamldoc pre{margin-bottom:4px;font-family:monospace}.ocamldoc .indextable{border-collapse:collapse}.ocamldoc .indextable td,.ocamldoc .indextable th{min-width:80px}.ocamldoc .indextable td.module>a,.ocamldoc .indextable td>.info{padding:8px 16px}.ocamldoc .indextable td>.info p{margin:0}.ocamldoc .indextable td.module{background-color:#eee}.ocamldoc .indextable td.module a{color:#4e6272;text-decoration:none;display:block;width:100%}.ocamldoc .indextable td.module a:hover{text-decoration:underline;background-color:transparent}.ocamldoc .deprecated{color:#888;font-style:italic}.ocamldoc .info-deprecated{display:block;margin:8px 0}.ocamldoc .info-deprecated .warning{display:block;padding-bottom:8px}.ocamldoc .indextable tr td div.info{margin-left:2px;margin-right:2px}.ocamldoc ul.indexlist{margin-left:0;padding-left:0}.ocamldoc ul.indexlist li{list-style-type:none;margin:0;padding-left:0}.ocamldoc ul.info-attributes{list-style:none;margin:0;padding:0}.ocamldoc .info-desc{margin-bottom:1em}.ocamldoc hr{border:none;border-bottom:1px solid #aaa;margin:16px 0}.ocamldoc .navbar{font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;padding-bottom:16px}.CodeMirror{font-family:monospace;height:300px;color:#000}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-invalidchar,.cm-s-default .cm-error{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;-webkit-font-feature-settings:"calt";font-feature-settings:"calt";font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}.CodeMirror-focused div.CodeMirror-cursors,div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}div{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;-ms-flex-negative:0;flex-shrink:0;min-width:0;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="-532304074"><style>.css-4msjtb,[data-css-4msjtb]{background-color:#db4d3f;flex-direction:row;justify-content:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:center;-webkit-box-pack:center;-webkit-justify-content:center;}</style><div class="css-4msjtb" data-reactid="2"><style>.css-1y8eyh,[data-css-1y8eyh]{color:white;}.css-11xmer7,[data-css-11xmer7]{max-width:1270px;flex:1;-webkit-flex:1;-ms-flex:1;}</style><div class="css-1y8eyh css-11xmer7" data-reactid="3"><!-- react-empty: 4 --><style>.css-yzv3nw,[data-css-yzv3nw]{flex-direction:row;justify-content:space-between;align-items:center;padding:10px 10px;padding-left:2em;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:justify;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-align:center;-webkit-box-align:center;-webkit-align-items:center;}@media(max-width: 400px){.css-yzv3nw,[data-css-yzv3nw]{padding-left:10px;height:auto;}}</style><div class="css-yzv3nw" data-reactid="5"><a style="text-decoration:none;color:currentColor;" href="/" data-reactid="6"><img style="width:50px;max-width:50px;margin:0;border:2px solid #f6f4f4;box-sizing:content-box;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAABGdBTUEAALGPC/xhBQAABh9JREFUeAHtm2toHFUUx8/s7CabbB67eaGhVWtFsWixCJX4bMT4gPSDglSLWlqqBq2SUpUiVhTFDyIIweITik0taKHF+vig+SCNFmuLVIu2iqG1ukmatJtukt1kn+Pc1T3Z7O5kJrvTzbnrGVhy7j1n7v7v/5d53UyUgc42DXgj4YCiKL0OEkpYBDrAQNAKGgEDocEBVTAQtIJGwEBocEAVDAStoBEwEBocUAUDQStoBAyEBgdUwUDQChoBA6HBAVUwELSCRsBAaHBAFQwEraARMBAaHFAFA0EraAQMhAYHVMFA0AoaAQOhwQFVMBC0gkbAQGhwQBUMBK2gETAQGhxQBQNBK2gEDIQGB1TBQNAKGgEDocEBVTAQtIJGwEBocEAVDAStoBEwEBocUAUDQStoBAyEBgdUwUDQChoBA6HBAVUwELSCRsBAaHBAFQwEraARMBAaHFAFA0EraAQMhAYHVMFA0AoaAQOhwQFVMBC0gkbAQGhwQBUMBK2gETAQGhxQBQNBK2gEDIQGB1TBQNAKGgEDocEBVTAQtIJG4CyVjCX7DhT9VVo0AsnJCUiEJiFxPgDRP07A9O+/QuTEMb09VvD4Lc++DJ4b2wvev6AdtSScvG9Vzq4lA6I4i/8qMYaj2gPpkapXrExNSEskIHzkIIx/uRemfjyUM0nTDocKdugz/Z6MAi2ZzGjNhOm5zfRIGCmqCp4bbkl9po//DCNvvgLxIb+EMwEou2uI++rlsKinF2ra72YgVBxwuN3Q3P0C1NzWQUWSZR1ld4SkZ644HNC8eRu4r7ku3SXFz7IFItxXVCc0dW3RT8zyTJPURV1LxCERPG/4m6zW1oHiqjDM50tUXLoUau/ohImv9udLz6tP3Gob3R3NayBRLMNdVvT0SfA/vc54booCzqYWqLjsCvA+sB7cVy4zrs3I1LTfZQsQ/3Nd+t3b3xkj2x/KcyyLuWsaxEfPQPjwdzC4ZSOc2/GWJUfEnZfDU2updqGL5AKS5VZw724IHfwmqze3KZ5T3MuW5yYI9kgNRPgZ+PBtS7aqvkZLdQtdJD2QmH5OT0Yipj6qXp9pDYUC6YGkrivD5hdapdJNwW9TDaRue03VGhSoviaDzEx3InB2plFgJG6553vbne+rtFg0X3eqT3ogjnofqHX1hhNMJ+LnRtNhwT8Xb99V8L6ZO55a0wHJcCizC2PpT1m1q+7EycwVxM+OzJUmk5MaiKt1Mfge7jI1U5wiYv7TpnUUCuQ8ZelP7LUdq6HhkcfBUVlp6mPo+37QpsKmdRQKSAFRvY3gfXCDoS9qnRdcrYug4pLLU0sohoVZiYm+z7N66DZJAXH6GqBh7UZb3YqNDMHU0cO2jnkhB5P6GmJmjFg9HnnjJcOVVbP9FyJP6gix24DAju0QOX7MtmFjw4Mw6xlCX+wUD6b/biIWzcx2qgPT/xXMuYRftkCCn+2B4Kcf2wZDDDT0YvcFX34vOyCJ8SCM9rwG4UP9tsIo1WBlBUSLxcC/eT3ER4ZL5Z/t31NWF3XF5dJf/7nHdpNKOSCpI0T8NTCw+wPD+XvvXas/gywxzIuEb806CPX3QWzwrznrqCZJAUlMjsNk3xeGXiX168NF2143zIuEWI1t2rQVhp5/cs46qkmpTlnhH76F6d9+MfWy6toV+tJKp2ndfAtSS+9OF4BdH/2d4uyN1BGSLS5fO9D7LrS+2pMvNauvYcOm1MsQxbwVP2tAvWHX8nt63LE9O2Fs5zvpZuqnVEeIUDz90xGY0j9mm1pTB42PdpuVkctLB0Q4KI4SK1vNrR1QdX2blVIyNVICiejXkZDFB7+mJ54BWf6eLn4rpAQihI/tei9j3Uj05N9cLReD76HH8icJ9koLJHpqAEIHvrZkaf3q+6Fi6VWWahe6SFogwrjAR++DWGI328Sbi81PbZXiLfiS3fZGLfxNO35myMzbWXnxb2vB/Z9A9cqbZ/XnayjuKvDcdHvqKT47nwiMghV92fsV206O577prwx0tqUX8Isdn/cv0gFFUXqlPmUVOX+SuzMQYlgYCAMh5gAxOXyEMBBiDhCTw0cIMSBOBZSjxDT9f+Uo8Oc/4JtPde0zwz8AAAAASUVORK5CYII=" width="50" data-reactid="7"/></a><style>.css-1gwiyn6,[data-css-1gwiyn6]{flex-direction:row;flex:1;overflow:auto;justify-content:flex-end;font-family:Helvetica Neue,Helvetica,Arial,Lucida Grande,sans-serif;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-webkit-flex:1;-ms-flex:1;-ms-flex-pack:end;-webkit-box-pack:end;-webkit-justify-content:flex-end;}</style><div class="css-1gwiyn6" data-reactid="8"><style>.css-hqlbx8,[data-css-hqlbx8]{padding:15px;}@media(max-width: 550px){.css-hqlbx8,[data-css-hqlbx8]{padding:5px;}}@media(max-width: 400px){.css-hqlbx8,[data-css-hqlbx8]{padding:5px;font-size:.9em;}}.css-1coze92,[data-css-1coze92]{text-decoration:none;color:currentColor;}.css-1coze92:hover,[data-css-1coze92]:hover{text-decoration:underline;}</style><a class="css-hqlbx8 css-1coze92" href="/guide/javascript/quickstart" data-reactid="9">Quick Start</a><a class="css-hqlbx8 css-1coze92" href="/try/" data-reactid="10">Try</a><a class="css-hqlbx8 css-1coze92" href="/guide/" data-reactid="11">Guide</a><a class="css-hqlbx8 css-1coze92" href="/api/index.html" data-reactid="12">API</a><a class="css-hqlbx8 css-1coze92" href="/community/" data-reactid="13">Community</a><a class="css-hqlbx8 css-1coze92" href="/community/blog/" data-reactid="14">Blog</a><a href="https://github.com/facebook/reason" class="css-hqlbx8 css-1coze92" data-reactid="15">GitHub</a></div></div><style>.css-1k8tu3j,[data-css-1k8tu3j]{align-items:center;-ms-flex-align:center;-webkit-box-align:center;-webkit-align-items:center;}</style><div class="css-1k8tu3j" data-reactid="16"><h1 data-reactid="17"><a class="css-1coze92" href="/api/index.html" data-reactid="18">API</a></h1></div></div></div><style>.css-1q2z82c,[data-css-1q2z82c]{flex-direction:row;justify-content:center;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-webkit-flex-direction:row;-ms-flex-direction:row;-ms-flex-pack:center;-webkit-box-pack:center;-webkit-justify-content:center;}</style><div class="css-1q2z82c" data-reactid="19"><style>.css-1s5h41q,[data-css-1s5h41q]{padding:36px 24px 0;}</style><div class="css-1s5h41q css-11xmer7" data-reactid="20"><h2 data-reactid="21">Standard Library</h2><style>.css-5p2jfz,[data-css-5p2jfz]{max-width:1270px;}</style><p class="css-5p2jfz" data-reactid="22"><!-- react-text: 23 -->Below is the API for the OCaml standard library. It&#x27;s directly copied over from <!-- /react-text --><a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/index.html" data-reactid="24">the OCaml Manual</a><!-- react-text: 25 -->, formatted to the Reason syntax and styled accordingly. The API docs are work-in-progress; we&#x27;ll be polishing these gradually!<!-- /react-text --></p></div></div><div class="css-1k8tu3j" data-reactid="26"><style>.css-wccihi,[data-css-wccihi]{max-width:1270px;width:100%;}</style><div class="css-wccihi" data-reactid="27"><div class="ocamldoc">
<div class="navbar"><a class="pre" href="Random.html" title="Random">Previous</a>
&#xA0;<a class="up" href="index.html" title="Index">Up</a>
&#xA0;<a class="post" href="Set.html" title="Set">Next</a>
</div>
<h1>Module <a href="type_Scanf.html">Scanf</a></h1>

<pre><span class="keyword">module</span> Scanf: sig .. end</pre><div class="info module top">
Formatted input functions.<br>
</div>
<hr width="100%">
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.
<p>

    For instance,
</p><p>
</p><ul>
<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is
    the predefined formatted input channel that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the
    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we
    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the
    keyboard, we get <code class="code">42</code> as the final result.<br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.
<p>

    For instance,
</p><p>
</p><ul>
<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is
    the predefined formatted input channel that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the
    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we
    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the
    keyboard, we get <code class="code">42</code> as the final result.<br>
<br>
<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.
<p>

    For instance,
</p><p>
</p><ul>
<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is
    the predefined formatted input channel that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the
    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we
    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the
    keyboard, we get <code class="code">42</code> as the final result.<br>
<br>
<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>
<br>
The OCaml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful:
    the formatted input functions are higher-order functionals and the
    parameter passing mechanism is just the regular function application not
    the variable assignment based mechanism which is typical for formatted
    input in imperative languages; the OCaml format strings also feature
    useful additions to easily define complex tokens; as expected within a
    functional programming language, the formatted input functions also
    support polymorphism, in particular arbitrary interaction with
    polymorphic user-defined scanners. Furthermore, the OCaml formatted input
    facility is fully type-checked at compile time.<br>
<br>
<h6 id="6_Introduction">Introduction</h6><br>
<br>
<div class="h7" id="7_Functionalinputwithformatstrings">Functional input with format strings</div><br>
<br>
The module <code class="code">Scanf</code> provides formatted input functions or <em>scanners</em>.
<p>

    The formatted input functions can read from any kind of input, including
    strings, files, or anything that can return characters. The more general
    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>. The more general
    formatted input function reads from any scanning buffer and is named
    <code class="code">bscanf</code>.
</p><p>

    Generally speaking, the formatted input functions have 3 arguments:</p><ul>
<li>the first argument is a source of characters for the input,</li>
<li>the second argument is a format string that specifies the values to
      read,</li>
<li>the third argument is a <em>receiver function</em> that is applied to the
      values read.</li>
</ul>

    Hence, a typical call to the formatted input function <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a> is
    <code class="code">bscanf ic fmt f</code>, where:
<p>
</p><ul>
<li><code class="code">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href="Scanf.Scanning.html#TYPEin_channel"><code class="code">Scanf.Scanning.in_channel</code></a>),</li>
</ul>
<ul>
<li><code class="code">fmt</code> is a format string (the same format strings as those used to print
    material with module <a href="Printf.html"><code class="code">Printf</code></a> or <a href="Format.html"><code class="code">Format</code></a>),</li>
</ul>
<ul>
<li><code class="code">f</code> is a function that has as many arguments as the number of values to
    read in the input.</li>
</ul>
<br>
<br>
<div class="h7" id="7_Asimpleexample">A simple example</div><br>
<br>
As suggested above, the expression <code class="code">bscanf ic &quot;%d&quot; f</code> reads a decimal
    integer <code class="code">n</code> from the source of characters <code class="code">ic</code> and returns <code class="code">f n</code>.
<p>

    For instance,
</p><p>
</p><ul>
<li>if we use <code class="code">stdin</code> as the source of characters (<a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> is
    the predefined formatted input channel that reads from standard input),</li>
</ul>
<ul>
<li>if we define the receiver <code class="code">f</code> as <code class="code">let f x = x + 1</code>,</li>
</ul>

    then <code class="code">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class="code">n</code> from the
    standard input and returns <code class="code">f n</code> (that is <code class="code">n + 1</code>). Thus, if we
    evaluate <code class="code">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class="code">41</code> at the
    keyboard, we get <code class="code">42</code> as the final result.<br>
<br>
<div class="h7" id="7_Formattedinputasafunctionalfeature">Formatted input as a functional feature</div><br>
<br>
The OCaml scanning facility is reminiscent of the corresponding C feature.
    However, it is also largely different, simpler, and yet more powerful:
    the formatted input functions are higher-order functionals and the
    parameter passing mechanism is just the regular function application not
    the variable assignment based mechanism which is typical for formatted
    input in imperative languages; the OCaml format strings also feature
    useful additions to easily define complex tokens; as expected within a
    functional programming language, the formatted input functions also
    support polymorphism, in particular arbitrary interaction with
    polymorphic user-defined scanners. Furthermore, the OCaml formatted input
    facility is fully type-checked at compile time.<br>
<br>
<h6 id="6_Formattedinputchannel">Formatted input channel</h6><br>

<pre><span class="keyword">module</span> Scanning: sig .. end</pre><br>
<h6 id="6_Typeofformattedinputfunctions">Type of formatted input functions</h6><br>

<pre><span class="keyword">type</span> scanner &apos;a &apos;b &apos;c &apos;d = Pervasives.format6 &apos;a Scanning.in_channel &apos;b &apos;c (&apos;a =&gt; &apos;d) &apos;d =&gt; &apos;c;
</pre>
<div class="info ">
The type of formatted input scanners: <code class="code">(&apos;a, &apos;b, &apos;c, &apos;d) scanner</code>
    is the type of a formatted input function that reads from some
    formatted input channel according to some format string; more
    precisely, if <code class="code">scan</code> is some formatted input function, then <code class="code">scan
    ic fmt f</code> applies <code class="code">f</code> to the arguments specified by the format
    string <code class="code">fmt</code>, when <code class="code">scan</code> has read those arguments from the
    formatted input channel <code class="code">ic</code>.
<p>

    For instance, the <code class="code">scanf</code> function below has type <code class="code">(&apos;a, &apos;b, &apos;c, &apos;d)
    scanner</code>, since it is a formatted input function that reads from
    <code class="code">Scanning.stdin</code>: <code class="code">scanf fmt f</code> applies <code class="code">f</code> to the arguments specified by
    <code class="code">fmt</code>, reading those arguments from <code class="code">Pervasives.stdin</code> as expected.
</p><p>

    If the format <code class="code">fmt</code> has some <code class="code">%r</code> indications, the corresponding input
    functions must be provided before the receiver <code class="code">f</code> argument. For
    instance, if <code class="code">read_elem</code> is an input function for values of type <code class="code">t</code>,
    then <code class="code">bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code class="code">v</code> of type <code class="code">t</code> followed
    by a <code class="code">&apos;;&apos;</code> character, and returns <code class="code">f v</code>.<br>
<b>Since</b> 3.10.0<br>
</p></div>


<pre><span class="keyword">exception</span> Scan_failure string;
</pre>
<div class="info ">
The exception that formatted input functions raise when the input cannot
    be read according to the given format.<br>
</div>
<br>
<h6 id="6_Thegeneralformattedinputfunction">The general formatted input function</h6><br>

<pre><span class="keyword">let</span> bscanf: Scanning.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
<code class="code">bscanf ic fmt r1 ... rN f</code> reads arguments for the function <code class="code">f</code>, from the
    formatted input channel <code class="code">ic</code>, according to the format string <code class="code">fmt</code>, and
    applies <code class="code">f</code> to these values.
    The result of this call to <code class="code">f</code> is returned as the result of the entire
    <code class="code">bscanf</code> call.
    For instance, if <code class="code">f</code> is the function <code class="code">fun s i -&gt; i + 1</code>, then
    <code class="code">Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    Arguments <code class="code">r1</code> to <code class="code">rN</code> are user-defined input functions that read the
    argument corresponding to the <code class="code">%r</code> conversions specified in the format
    string.<br>
</p></div>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<div class="h7" id="indication">Scanning indications in format strings</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<div class="h7" id="indication">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    plain character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code">&quot;%s@\t&quot;</code> reads a string up to the next
    tab character or to the end of input. If a <code class="code">@</code> character appears
    anywhere else in the format string, it is treated as a plain character.
<p>

    Note:
</p><p>
</p><ul>
<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped
    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications
    and scanning indications.
    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>
<li>The scanning indications introduce slight differences in the syntax of
    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>
    module. However, the scanning indications are similar to those used in
    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned
    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the
    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish
    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>
    characters).</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<div class="h7" id="indication">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    plain character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code">&quot;%s@\t&quot;</code> reads a string up to the next
    tab character or to the end of input. If a <code class="code">@</code> character appears
    anywhere else in the format string, it is treated as a plain character.
<p>

    Note:
</p><p>
</p><ul>
<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped
    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications
    and scanning indications.
    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>
<li>The scanning indications introduce slight differences in the syntax of
    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>
    module. However, the scanning indications are similar to those used in
    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned
    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the
    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish
    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<div class="h7" id="indication">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    plain character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code">&quot;%s@\t&quot;</code> reads a string up to the next
    tab character or to the end of input. If a <code class="code">@</code> character appears
    anywhere else in the format string, it is treated as a plain character.
<p>

    Note:
</p><p>
</p><ul>
<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped
    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications
    and scanning indications.
    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>
<li>The scanning indications introduce slight differences in the syntax of
    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>
    module. However, the scanning indications are similar to those used in
    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned
    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the
    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish
    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
Scanners may raise the following exceptions when the input cannot be read
    according to the format string:
<p>
</p><ul>
<li>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</li>
</ul>
<ul>
<li>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</li>
</ul>
<ul>
<li>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more
      characters are needed to read the current conversion specification.</li>
</ul>
<ul>
<li>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</li>
</ul>

    Note:
<p>
</p><ul>
<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception
    <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and
    simply returns the characters read so far, or <code class="code">&quot;&quot;</code> if none were ever read.</li>
</ul>
<br>
<br>
<h6 id="6_Formatstringdescription">Format string description</h6><br>
<br>
The format string is a character string which contains three types of
    objects:<ul>
<li>plain characters, which are simply matched with the characters of the
      input (with a special case for space and line feed, see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>conversion specifications, each of which causes reading and conversion of
      one argument for the function <code class="code">f</code> (see <a href="Scanf.html#conversion"><i>Conversion specifications in format strings</i></a>),</li>
<li>scanning indications to specify boundaries of tokens
      (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>).</li>
</ul>
<br>
<br>
<div class="h7" id="space">The space character in format strings</div><br>
<br>
As mentioned above, a plain character in the format string is just
    matched with the next character of the input; however, two characters are
    special exceptions to this rule: the space character (<code class="code">&apos; &apos;</code> or ASCII code
    32) and the line feed character (<code class="code">&apos;\n&apos;</code> or ASCII code 10).
    A space does not match a single space character, but any amount of
    &apos;whitespace&apos; in the input. More precisely, a space inside the format
    string matches <em>any number</em> of tab, space, line feed and carriage
    return characters. Similarly, a line feed character in the format string
    matches either a single line feed or a carriage return followed by a line
    feed.
<p>

    Matching <em>any</em> amount of whitespace, a space in the format string
    also matches no amount of whitespace at all; hence, the call <code class="code">bscanf ib
    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class="code">1</code> when reading an
    input with various whitespace in it, such as <code class="code">Price = 1 $</code>,
    <code class="code">Price  =  1    $</code>, or even <code class="code">Price=1$</code>.<br>
<br>
</p><div class="h7" id="conversion">Conversion specifications in format strings</div><br>
<br>
Conversion specifications consist in the <code class="code">%</code> character, followed by
    an optional flag, an optional field width, and followed by one or
    two conversion characters. The conversion characters and their
    meanings are:
<p>
</p><ul>
<li><code class="code">d</code>: reads an optionally signed decimal integer.</li>
<li><code class="code">i</code>: reads an optionally signed integer
      (usual input conventions for decimal (<code class="code">0-9</code>+), hexadecimal
       (<code class="code">0x[0-9a-f]+</code> and <code class="code">0X[0-9A-F]+</code>), octal (<code class="code">0o[0-7]+</code>), and binary
       (<code class="code">0b[0-1]+</code>) notations are understood).</li>
<li><code class="code">u</code>: reads an unsigned decimal integer.</li>
<li><code class="code">x</code> or <code class="code">X</code>: reads an unsigned hexadecimal integer (<code class="code">[0-9a-fA-F]+</code>).</li>
<li><code class="code">o</code>: reads an unsigned octal integer (<code class="code">[0-7]+</code>).</li>
<li><code class="code">s</code>: reads a string argument that spreads as much as possible, until the
      following bounding condition holds: <ul>
<li>a whitespace has been found (see <a href="Scanf.html#space"><i>The space character in format strings</i></a>),</li>
<li>a scanning indication (see scanning <a href="Scanf.html#indication"><i>Scanning indications in format strings</i></a>) has been
         encountered,</li>
<li>the end-of-input has been reached.</li>
</ul>

      Hence, this conversion always succeeds: it returns an empty
      string if the bounding condition holds when the scan begins.</li>
<li><code class="code">S</code>: reads a delimited string argument (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">c</code>: reads a single character. To test the current input character
      without reading it, specify a null field width, i.e. use
      specification <code class="code">%0c</code>. Raise <code class="code">Invalid_argument</code>, if the field width
      specification is greater than 1.</li>
<li><code class="code">C</code>: reads a single delimited character (delimiters and special
      escaped characters follow the lexical conventions of OCaml).</li>
<li><code class="code">f</code>, <code class="code">e</code>, <code class="code">E</code>, <code class="code">g</code>, <code class="code">G</code>: reads an optionally signed
      floating-point number in decimal notation, in the style <code class="code">dddd.ddd
      e/E+-dd</code>.</li>
<li><code class="code">F</code>: reads a floating point number according to the lexical
      conventions of OCaml (hence the decimal point is mandatory if the
      exponent part is not mentioned).</li>
<li><code class="code">B</code>: reads a boolean argument (<code class="code">true</code> or <code class="code">false</code>).</li>
<li><code class="code">b</code>: reads a boolean argument (for backward compatibility; do not use
      in new programs).</li>
<li><code class="code">ld</code>, <code class="code">li</code>, <code class="code">lu</code>, <code class="code">lx</code>, <code class="code">lX</code>, <code class="code">lo</code>: reads an <code class="code">int32</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">nd</code>, <code class="code">ni</code>, <code class="code">nu</code>, <code class="code">nx</code>, <code class="code">nX</code>, <code class="code">no</code>: reads a <code class="code">nativeint</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">Ld</code>, <code class="code">Li</code>, <code class="code">Lu</code>, <code class="code">Lx</code>, <code class="code">LX</code>, <code class="code">Lo</code>: reads an <code class="code">int64</code> argument to
      the format specified by the second letter for regular integers.</li>
<li><code class="code">[ range ]</code>: reads characters that matches one of the characters
      mentioned in the range of characters <code class="code">range</code> (or not mentioned in
      it, if the range starts with <code class="code">^</code>). Reads a <code class="code">string</code> that can be
      empty, if the next input character does not match the range. The set of
      characters from <code class="code">c1</code> to <code class="code">c2</code> (inclusively) is denoted by <code class="code">c1-c2</code>.
      Hence, <code class="code">%[0-9]</code> returns a string representing a decimal number
      or an empty string if no decimal digit is found; similarly,
      <code class="code">%[0-9a-f]</code> returns a string of hexadecimal digits.
      If a closing bracket appears in a range, it must occur as the
      first character of the range (or just after the <code class="code">^</code> in case of
      range negation); hence <code class="code">[]]</code> matches a <code class="code">]</code> character and
      <code class="code">[^]]</code> matches any character that is not <code class="code">]</code>.
      Use <code class="code">%%</code> and <code class="code">%@</code> to include a <code class="code">%</code> or a <code class="code">@</code> in a range.</li>
<li><code class="code">r</code>: user-defined reader. Takes the next <code class="code">ri</code> formatted input
      function and applies it to the scanning buffer <code class="code">ib</code> to read the
      next argument. The input function <code class="code">ri</code> must therefore have type
      <code class="code">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class="code">&apos;a</code>.</li>
<li><code class="code">{ fmt %}</code>: reads a format string argument. The format string
      read must have the same type as the format string specification
      <code class="code">fmt</code>. For instance, <code class="code">&quot;%{ %i %}&quot;</code> reads any format string that
      can read a value of type <code class="code">int</code>; hence, if <code class="code">s</code> is the string
      <code class="code">&quot;fmt:\&quot;number is %u\&quot;&quot;</code>, then <code class="code">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>
      succeeds and returns the format string <code class="code">&quot;number is %u&quot;</code>.</li>
<li><code class="code">( fmt %)</code>: scanning sub-format substitution.
      Reads a format string <code class="code">rf</code> in the input, then goes on scanning with
      <code class="code">rf</code> instead of scanning with <code class="code">fmt</code>.
      The format string <code class="code">rf</code> must have the same type as the format string
      specification <code class="code">fmt</code> that it replaces.
      For instance, <code class="code">&quot;%( %i %)&quot;</code> reads any format string that can read a value
      of type <code class="code">int</code>.
      The conversion returns the format string read <code class="code">rf</code>, and then a value
      read using <code class="code">rf</code>.
      Hence, if <code class="code">s</code> is the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then
      <code class="code">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to
      <code class="code">(&quot;%4d&quot;, 1234)</code>.
      This behaviour is not mere format substitution, since the conversion
      returns the format string read as additional argument. If you need
      pure format substitution, use special flag <code class="code">_</code> to discard the
      extraneous argument: conversion <code class="code">%_( fmt %)</code> reads a format string
      <code class="code">rf</code> and then behaves the same as format string <code class="code">rf</code>.  Hence, if <code class="code">s</code> is
      the string <code class="code">&quot;\&quot;%4d\&quot;1234.00&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is
      simply equivalent to <code class="code">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>
<li><code class="code">l</code>: returns the number of lines read so far.</li>
<li><code class="code">n</code>: returns the number of characters read so far.</li>
<li><code class="code">N</code> or <code class="code">L</code>: returns the number of tokens read so far.</li>
<li><code class="code">!</code>: matches the end of input condition.</li>
<li><code class="code">%</code>: matches one <code class="code">%</code> character in the input.</li>
<li><code class="code">@</code>: matches one <code class="code">@</code> character in the input.</li>
<li><code class="code">,</code>: does nothing.</li>
</ul>

    Following the <code class="code">%</code> character that introduces a conversion, there may be
    the special flag <code class="code">_</code>: the conversion that follows occurs as usual,
    but the resulting value is discarded.
    For instance, if <code class="code">f</code> is the function <code class="code">fun i -&gt; i + 1</code>, and <code class="code">s</code> is the
    string <code class="code">&quot;x = 1&quot;</code>, then <code class="code">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class="code">2</code>.
<p>

    The field width is composed of an optional integer literal
    indicating the maximal width of the token to read.
    For instance, <code class="code">%6d</code> reads an integer, having at most 6 decimal digits;
    <code class="code">%4f</code> reads a float with at most 4 characters; and <code class="code">%8[\000-\255]</code>
    returns the next 8 characters (or all the characters still available,
    if fewer than 8 characters are available in the input).
</p><p>

    Notes:
</p><p>
</p><ul>
<li>as mentioned above, a <code class="code">%s</code> conversion always succeeds, even if there is
      nothing to read in the input: in this case, it simply returns <code class="code">&quot;&quot;</code>.</li>
</ul>
<ul>
<li>in addition to the relevant digits, <code class="code">&apos;_&apos;</code> characters may appear
    inside numbers (this is reminiscent to the usual OCaml lexical
    conventions). If stricter scanning is desired, use the range
    conversion facility instead of the number conversions.</li>
</ul>
<ul>
<li>the <code class="code">scanf</code> facility is not intended for heavy duty lexical
    analysis and parsing. If it appears not expressive enough for your
    needs, several alternative exists: regular expressions (module
    <code class="code">Str</code>), stream parsers, <code class="code">ocamllex</code>-generated lexers,
    <code class="code">ocamlyacc</code>-generated parsers.</li>
</ul>
<br>
<br>
<div class="h7" id="indication">Scanning indications in format strings</div><br>
<br>
Scanning indications appear just after the string conversions <code class="code">%s</code>
    and <code class="code">%[ range ]</code> to delimit the end of the token. A scanning
    indication is introduced by a <code class="code">@</code> character, followed by some
    plain character <code class="code">c</code>. It means that the string token should end
    just before the next matching <code class="code">c</code> (which is skipped). If no <code class="code">c</code>
    character is encountered, the string token spreads as much as
    possible. For instance, <code class="code">&quot;%s@\t&quot;</code> reads a string up to the next
    tab character or to the end of input. If a <code class="code">@</code> character appears
    anywhere else in the format string, it is treated as a plain character.
<p>

    Note:
</p><p>
</p><ul>
<li>As usual in format strings, <code class="code">%</code> and <code class="code">@</code> characters must be escaped
    using <code class="code">%%</code> and <code class="code">%@</code>; this rule still holds within range specifications
    and scanning indications.
    For instance, <code class="code">&quot;%s@%%&quot;</code> reads a string up to the next <code class="code">%</code> character.</li>
<li>The scanning indications introduce slight differences in the syntax of
    <code class="code">Scanf</code> format strings, compared to those used for the <code class="code">Printf</code>
    module. However, the scanning indications are similar to those used in
    the <code class="code">Format</code> module; hence, when producing formatted text to be scanned
    by <code class="code">!Scanf.bscanf</code>, it is wise to use printing functions from the
    <code class="code">Format</code> module (or, if you need to use functions from <code class="code">Printf</code>, banish
    or carefully double check the format strings that contain <code class="code">&apos;@&apos;</code>
    characters).</li>
</ul>
<br>
<br>
<div class="h7" id="7_Exceptionsduringscanning">Exceptions during scanning</div><br>
<br>
Scanners may raise the following exceptions when the input cannot be read
    according to the format string:
<p>
</p><ul>
<li>Raise <code class="code">Scanf.Scan_failure</code> if the input does not match the format.</li>
</ul>
<ul>
<li>Raise <code class="code">Failure</code> if a conversion to a number is not possible.</li>
</ul>
<ul>
<li>Raise <code class="code">End_of_file</code> if the end of input is encountered while some more
      characters are needed to read the current conversion specification.</li>
</ul>
<ul>
<li>Raise <code class="code">Invalid_argument</code> if the format string is invalid.</li>
</ul>

    Note:
<p>
</p><ul>
<li>as a consequence, scanning a <code class="code">%s</code> conversion never raises exception
    <code class="code">End_of_file</code>: if the end of input is reached the conversion succeeds and
    simply returns the characters read so far, or <code class="code">&quot;&quot;</code> if none were ever read.</li>
</ul>
<br>
<br>
<h6 id="6_Specialisedformattedinputfunctions">Specialised formatted input functions</h6><br>

<pre><span class="keyword">let</span> fscanf: Pervasives.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given regular input channel.
<p>

    Warning: since all formatted input functions operate from a <em>formatted
    input channel</em>, be aware that each <code class="code">fscanf</code> invocation will operate with a
    formatted input channel reading from the given channel. This extra level
    of bufferization can lead to a strange scanning behaviour if you use low
    level primitives on the channel (reading characters, seeking the reading
    position, and so on).
</p><p>

    As a consequence, never mix direct low level reading and high level
    scanning from the same regular input channel.<br>
</p></div>

<pre><span class="keyword">let</span> sscanf: string =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the given string.<br>
</div>

<pre><span class="keyword">let</span> scanf: scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but reads from the predefined formatted input
    channel <a href="Scanf.Scanning.html#VALstdin"><code class="code">Scanf.Scanning.stdin</code></a> that is connected to <code class="code">Pervasives.stdin</code>.<br>
</div>

<pre><span class="keyword">let</span> kscanf: Scanning.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALbscanf"><code class="code">Scanf.bscanf</code></a>, but takes an additional function argument
    <code class="code">ef</code> that is called in case of error: if the scanning process or
    some conversion fails, the scanning function aborts and calls the
    error handling function <code class="code">ef</code> with the formatted input channel and the
    exception that aborted the scanning process as arguments.<br>
</div>

<pre><span class="keyword">let</span> ksscanf: string =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALkscanf"><code class="code">Scanf.kscanf</code></a> but reads from the given string.<br>
<b>Since</b> 4.02.0<br>
</div>

<pre><span class="keyword">let</span> kfscanf: Pervasives.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;
</pre><div class="info ">
Same as <a href="Scanf.html#VALkscanf"><code class="code">Scanf.kscanf</code></a>, but reads from the given regular input channel.<br>
<b>Since</b> 4.02.0<br>
</div>
<br>
<h6 id="6_Readingformatstringsfrominput">Reading format strings from input</h6><br>

<pre><span class="keyword">let</span> bscanf_format:
  Scanning.in_channel =&gt;
  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;
  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;
  &apos;g;
</pre><div class="info ">
<code class="code">bscanf_format ic fmt f</code> reads a format string token from the formatted
    input channel <code class="code">ic</code>, according to the given format string <code class="code">fmt</code>, and
    applies <code class="code">f</code> to the resulting format string value.
    Raise <code class="code">Scan_failure</code> if the format string value read does not have the
    same type as <code class="code">fmt</code>.<br>
<b>Since</b> 3.09.0<br>
</div>

<pre><span class="keyword">let</span> sscanf_format:
  string =&gt;
  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;
  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;
  &apos;g;
</pre><div class="info ">
Same as <a href="Scanf.html#VALbscanf_format"><code class="code">Scanf.bscanf_format</code></a>, but reads from the given string.<br>
<b>Since</b> 3.09.0<br>
</div>

<pre><span class="keyword">let</span> format_from_string:
  string =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f;
</pre><div class="info ">
<code class="code">format_from_string s fmt</code> converts a string argument to a format string,
    according to the given format string <code class="code">fmt</code>.
    Raise <code class="code">Scan_failure</code> if <code class="code">s</code>, considered as a format string, does not
    have the same type as <code class="code">fmt</code>.<br>
<b>Since</b> 3.10.0<br>
</div>

<pre><span class="keyword">let</span> unescaped: string =&gt; string;
</pre><div class="info ">
Return a copy of the argument with escape sequences, following the
    lexical conventions of OCaml, replaced by their corresponding
    special characters. If there is no escape sequence in the
    argument, still return a copy, contrary to String.escaped.<br>
<b>Since</b> 4.00.0<br>
</div>
</div></div></div></div></div></body></html>